# **********************************************************************
#
# Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.6.1
#
# <auto-generated>
#
# Generated from file `Murmur.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy
import Ice_SliceChecksumDict_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Start of module Murmur
_M_Murmur = Ice.openModule('Murmur')
__name__ = 'Murmur'

if '_t_NetAddress' not in _M_Murmur.__dict__:
    _M_Murmur._t_NetAddress = IcePy.defineSequence('::Murmur::NetAddress', ('python:seq:tuple',), IcePy._t_byte)

if 'User' not in _M_Murmur.__dict__:
    _M_Murmur.User = Ice.createTempClass()
    class User(object):
        '''A connected user.'''
        def __init__(self, session=0, userid=0, mute=False, deaf=False, suppress=False, prioritySpeaker=False, selfMute=False, selfDeaf=False, recording=False, channel=0, name='', onlinesecs=0, bytespersec=0, version=0, release='', os='', osversion='', identity='', context='', comment='', address=None, tcponly=False, idlesecs=0, udpPing=0.0, tcpPing=0.0):
            self.session = session
            self.userid = userid
            self.mute = mute
            self.deaf = deaf
            self.suppress = suppress
            self.prioritySpeaker = prioritySpeaker
            self.selfMute = selfMute
            self.selfDeaf = selfDeaf
            self.recording = recording
            self.channel = channel
            self.name = name
            self.onlinesecs = onlinesecs
            self.bytespersec = bytespersec
            self.version = version
            self.release = release
            self.os = os
            self.osversion = osversion
            self.identity = identity
            self.context = context
            self.comment = comment
            self.address = address
            self.tcponly = tcponly
            self.idlesecs = idlesecs
            self.udpPing = udpPing
            self.tcpPing = tcpPing

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Murmur.User):
                return NotImplemented
            else:
                if self.session != other.session:
                    return False
                if self.userid != other.userid:
                    return False
                if self.mute != other.mute:
                    return False
                if self.deaf != other.deaf:
                    return False
                if self.suppress != other.suppress:
                    return False
                if self.prioritySpeaker != other.prioritySpeaker:
                    return False
                if self.selfMute != other.selfMute:
                    return False
                if self.selfDeaf != other.selfDeaf:
                    return False
                if self.recording != other.recording:
                    return False
                if self.channel != other.channel:
                    return False
                if self.name != other.name:
                    return False
                if self.onlinesecs != other.onlinesecs:
                    return False
                if self.bytespersec != other.bytespersec:
                    return False
                if self.version != other.version:
                    return False
                if self.release != other.release:
                    return False
                if self.os != other.os:
                    return False
                if self.osversion != other.osversion:
                    return False
                if self.identity != other.identity:
                    return False
                if self.context != other.context:
                    return False
                if self.comment != other.comment:
                    return False
                if self.address != other.address:
                    return False
                if self.tcponly != other.tcponly:
                    return False
                if self.idlesecs != other.idlesecs:
                    return False
                if self.udpPing != other.udpPing:
                    return False
                if self.tcpPing != other.tcpPing:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_User)

        __repr__ = __str__

    _M_Murmur._t_User = IcePy.defineStruct('::Murmur::User', User, (), (
        ('session', (), IcePy._t_int),
        ('userid', (), IcePy._t_int),
        ('mute', (), IcePy._t_bool),
        ('deaf', (), IcePy._t_bool),
        ('suppress', (), IcePy._t_bool),
        ('prioritySpeaker', (), IcePy._t_bool),
        ('selfMute', (), IcePy._t_bool),
        ('selfDeaf', (), IcePy._t_bool),
        ('recording', (), IcePy._t_bool),
        ('channel', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('onlinesecs', (), IcePy._t_int),
        ('bytespersec', (), IcePy._t_int),
        ('version', (), IcePy._t_int),
        ('release', (), IcePy._t_string),
        ('os', (), IcePy._t_string),
        ('osversion', (), IcePy._t_string),
        ('identity', (), IcePy._t_string),
        ('context', (), IcePy._t_string),
        ('comment', (), IcePy._t_string),
        ('address', (), _M_Murmur._t_NetAddress),
        ('tcponly', (), IcePy._t_bool),
        ('idlesecs', (), IcePy._t_int),
        ('udpPing', (), IcePy._t_float),
        ('tcpPing', (), IcePy._t_float)
    ))

    _M_Murmur.User = User
    del User

if '_t_IntList' not in _M_Murmur.__dict__:
    _M_Murmur._t_IntList = IcePy.defineSequence('::Murmur::IntList', (), IcePy._t_int)

if 'TextMessage' not in _M_Murmur.__dict__:
    _M_Murmur.TextMessage = Ice.createTempClass()
    class TextMessage(object):
        '''A text message between users.'''
        def __init__(self, sessions=None, channels=None, trees=None, text=''):
            self.sessions = sessions
            self.channels = channels
            self.trees = trees
            self.text = text

        def __hash__(self):
            _h = 0
            if self.sessions:
                for _i0 in self.sessions:
                    _h = 5 * _h + Ice.getHash(_i0)
            if self.channels:
                for _i1 in self.channels:
                    _h = 5 * _h + Ice.getHash(_i1)
            if self.trees:
                for _i2 in self.trees:
                    _h = 5 * _h + Ice.getHash(_i2)
            _h = 5 * _h + Ice.getHash(self.text)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.TextMessage):
                return NotImplemented
            else:
                if self.sessions is None or other.sessions is None:
                    if self.sessions != other.sessions:
                        return (-1 if self.sessions is None else 1)
                else:
                    if self.sessions < other.sessions:
                        return -1
                    elif self.sessions > other.sessions:
                        return 1
                if self.channels is None or other.channels is None:
                    if self.channels != other.channels:
                        return (-1 if self.channels is None else 1)
                else:
                    if self.channels < other.channels:
                        return -1
                    elif self.channels > other.channels:
                        return 1
                if self.trees is None or other.trees is None:
                    if self.trees != other.trees:
                        return (-1 if self.trees is None else 1)
                else:
                    if self.trees < other.trees:
                        return -1
                    elif self.trees > other.trees:
                        return 1
                if self.text is None or other.text is None:
                    if self.text != other.text:
                        return (-1 if self.text is None else 1)
                else:
                    if self.text < other.text:
                        return -1
                    elif self.text > other.text:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_TextMessage)

        __repr__ = __str__

    _M_Murmur._t_TextMessage = IcePy.defineStruct('::Murmur::TextMessage', TextMessage, (), (
        ('sessions', (), _M_Murmur._t_IntList),
        ('channels', (), _M_Murmur._t_IntList),
        ('trees', (), _M_Murmur._t_IntList),
        ('text', (), IcePy._t_string)
    ))

    _M_Murmur.TextMessage = TextMessage
    del TextMessage

if 'Channel' not in _M_Murmur.__dict__:
    _M_Murmur.Channel = Ice.createTempClass()
    class Channel(object):
        '''A channel.'''
        def __init__(self, id=0, name='', parent=0, links=None, description='', temporary=False, position=0):
            self.id = id
            self.name = name
            self.parent = parent
            self.links = links
            self.description = description
            self.temporary = temporary
            self.position = position

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.id)
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.parent)
            if self.links:
                for _i0 in self.links:
                    _h = 5 * _h + Ice.getHash(_i0)
            _h = 5 * _h + Ice.getHash(self.description)
            _h = 5 * _h + Ice.getHash(self.temporary)
            _h = 5 * _h + Ice.getHash(self.position)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.Channel):
                return NotImplemented
            else:
                if self.id is None or other.id is None:
                    if self.id != other.id:
                        return (-1 if self.id is None else 1)
                else:
                    if self.id < other.id:
                        return -1
                    elif self.id > other.id:
                        return 1
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.parent is None or other.parent is None:
                    if self.parent != other.parent:
                        return (-1 if self.parent is None else 1)
                else:
                    if self.parent < other.parent:
                        return -1
                    elif self.parent > other.parent:
                        return 1
                if self.links is None or other.links is None:
                    if self.links != other.links:
                        return (-1 if self.links is None else 1)
                else:
                    if self.links < other.links:
                        return -1
                    elif self.links > other.links:
                        return 1
                if self.description is None or other.description is None:
                    if self.description != other.description:
                        return (-1 if self.description is None else 1)
                else:
                    if self.description < other.description:
                        return -1
                    elif self.description > other.description:
                        return 1
                if self.temporary is None or other.temporary is None:
                    if self.temporary != other.temporary:
                        return (-1 if self.temporary is None else 1)
                else:
                    if self.temporary < other.temporary:
                        return -1
                    elif self.temporary > other.temporary:
                        return 1
                if self.position is None or other.position is None:
                    if self.position != other.position:
                        return (-1 if self.position is None else 1)
                else:
                    if self.position < other.position:
                        return -1
                    elif self.position > other.position:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Channel)

        __repr__ = __str__

    _M_Murmur._t_Channel = IcePy.defineStruct('::Murmur::Channel', Channel, (), (
        ('id', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('parent', (), IcePy._t_int),
        ('links', (), _M_Murmur._t_IntList),
        ('description', (), IcePy._t_string),
        ('temporary', (), IcePy._t_bool),
        ('position', (), IcePy._t_int)
    ))

    _M_Murmur.Channel = Channel
    del Channel

if 'Group' not in _M_Murmur.__dict__:
    _M_Murmur.Group = Ice.createTempClass()
    class Group(object):
        '''A group. Groups are defined per channel, and can inherit members from parent channels.'''
        def __init__(self, name='', inherited=False, inherit=False, inheritable=False, add=None, remove=None, members=None):
            self.name = name
            self.inherited = inherited
            self.inherit = inherit
            self.inheritable = inheritable
            self.add = add
            self.remove = remove
            self.members = members

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.inherited)
            _h = 5 * _h + Ice.getHash(self.inherit)
            _h = 5 * _h + Ice.getHash(self.inheritable)
            if self.add:
                for _i0 in self.add:
                    _h = 5 * _h + Ice.getHash(_i0)
            if self.remove:
                for _i1 in self.remove:
                    _h = 5 * _h + Ice.getHash(_i1)
            if self.members:
                for _i2 in self.members:
                    _h = 5 * _h + Ice.getHash(_i2)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.Group):
                return NotImplemented
            else:
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.inherited is None or other.inherited is None:
                    if self.inherited != other.inherited:
                        return (-1 if self.inherited is None else 1)
                else:
                    if self.inherited < other.inherited:
                        return -1
                    elif self.inherited > other.inherited:
                        return 1
                if self.inherit is None or other.inherit is None:
                    if self.inherit != other.inherit:
                        return (-1 if self.inherit is None else 1)
                else:
                    if self.inherit < other.inherit:
                        return -1
                    elif self.inherit > other.inherit:
                        return 1
                if self.inheritable is None or other.inheritable is None:
                    if self.inheritable != other.inheritable:
                        return (-1 if self.inheritable is None else 1)
                else:
                    if self.inheritable < other.inheritable:
                        return -1
                    elif self.inheritable > other.inheritable:
                        return 1
                if self.add is None or other.add is None:
                    if self.add != other.add:
                        return (-1 if self.add is None else 1)
                else:
                    if self.add < other.add:
                        return -1
                    elif self.add > other.add:
                        return 1
                if self.remove is None or other.remove is None:
                    if self.remove != other.remove:
                        return (-1 if self.remove is None else 1)
                else:
                    if self.remove < other.remove:
                        return -1
                    elif self.remove > other.remove:
                        return 1
                if self.members is None or other.members is None:
                    if self.members != other.members:
                        return (-1 if self.members is None else 1)
                else:
                    if self.members < other.members:
                        return -1
                    elif self.members > other.members:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Group)

        __repr__ = __str__

    _M_Murmur._t_Group = IcePy.defineStruct('::Murmur::Group', Group, (), (
        ('name', (), IcePy._t_string),
        ('inherited', (), IcePy._t_bool),
        ('inherit', (), IcePy._t_bool),
        ('inheritable', (), IcePy._t_bool),
        ('add', (), _M_Murmur._t_IntList),
        ('remove', (), _M_Murmur._t_IntList),
        ('members', (), _M_Murmur._t_IntList)
    ))

    _M_Murmur.Group = Group
    del Group

_M_Murmur.PermissionWrite = 1

_M_Murmur.PermissionTraverse = 2

_M_Murmur.PermissionEnter = 4

_M_Murmur.PermissionSpeak = 8

_M_Murmur.PermissionWhisper = 256

_M_Murmur.PermissionMuteDeafen = 16

_M_Murmur.PermissionMove = 32

_M_Murmur.PermissionMakeChannel = 64

_M_Murmur.PermissionMakeTempChannel = 1024

_M_Murmur.PermissionLinkChannel = 128

_M_Murmur.PermissionTextMessage = 512

_M_Murmur.PermissionKick = 65536

_M_Murmur.PermissionBan = 131072

_M_Murmur.PermissionRegister = 262144

_M_Murmur.PermissionRegisterSelf = 524288

if 'ACL' not in _M_Murmur.__dict__:
    _M_Murmur.ACL = Ice.createTempClass()
    class ACL(object):
        '''Access Control List for a channel. ACLs are defined per channel, and can be inherited from parent channels.'''
        def __init__(self, applyHere=False, applySubs=False, inherited=False, userid=0, group='', allow=0, deny=0):
            self.applyHere = applyHere
            self.applySubs = applySubs
            self.inherited = inherited
            self.userid = userid
            self.group = group
            self.allow = allow
            self.deny = deny

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.applyHere)
            _h = 5 * _h + Ice.getHash(self.applySubs)
            _h = 5 * _h + Ice.getHash(self.inherited)
            _h = 5 * _h + Ice.getHash(self.userid)
            _h = 5 * _h + Ice.getHash(self.group)
            _h = 5 * _h + Ice.getHash(self.allow)
            _h = 5 * _h + Ice.getHash(self.deny)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.ACL):
                return NotImplemented
            else:
                if self.applyHere is None or other.applyHere is None:
                    if self.applyHere != other.applyHere:
                        return (-1 if self.applyHere is None else 1)
                else:
                    if self.applyHere < other.applyHere:
                        return -1
                    elif self.applyHere > other.applyHere:
                        return 1
                if self.applySubs is None or other.applySubs is None:
                    if self.applySubs != other.applySubs:
                        return (-1 if self.applySubs is None else 1)
                else:
                    if self.applySubs < other.applySubs:
                        return -1
                    elif self.applySubs > other.applySubs:
                        return 1
                if self.inherited is None or other.inherited is None:
                    if self.inherited != other.inherited:
                        return (-1 if self.inherited is None else 1)
                else:
                    if self.inherited < other.inherited:
                        return -1
                    elif self.inherited > other.inherited:
                        return 1
                if self.userid is None or other.userid is None:
                    if self.userid != other.userid:
                        return (-1 if self.userid is None else 1)
                else:
                    if self.userid < other.userid:
                        return -1
                    elif self.userid > other.userid:
                        return 1
                if self.group is None or other.group is None:
                    if self.group != other.group:
                        return (-1 if self.group is None else 1)
                else:
                    if self.group < other.group:
                        return -1
                    elif self.group > other.group:
                        return 1
                if self.allow is None or other.allow is None:
                    if self.allow != other.allow:
                        return (-1 if self.allow is None else 1)
                else:
                    if self.allow < other.allow:
                        return -1
                    elif self.allow > other.allow:
                        return 1
                if self.deny is None or other.deny is None:
                    if self.deny != other.deny:
                        return (-1 if self.deny is None else 1)
                else:
                    if self.deny < other.deny:
                        return -1
                    elif self.deny > other.deny:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ACL)

        __repr__ = __str__

    _M_Murmur._t_ACL = IcePy.defineStruct('::Murmur::ACL', ACL, (), (
        ('applyHere', (), IcePy._t_bool),
        ('applySubs', (), IcePy._t_bool),
        ('inherited', (), IcePy._t_bool),
        ('userid', (), IcePy._t_int),
        ('group', (), IcePy._t_string),
        ('allow', (), IcePy._t_int),
        ('deny', (), IcePy._t_int)
    ))

    _M_Murmur.ACL = ACL
    del ACL

if 'Ban' not in _M_Murmur.__dict__:
    _M_Murmur.Ban = Ice.createTempClass()
    class Ban(object):
        '''A single ip mask for a ban.'''
        def __init__(self, address=None, bits=0, name='', hash='', reason='', start=0, duration=0):
            self.address = address
            self.bits = bits
            self.name = name
            self.hash = hash
            self.reason = reason
            self.start = start
            self.duration = duration

        def __hash__(self):
            _h = 0
            if self.address:
                for _i0 in self.address:
                    _h = 5 * _h + Ice.getHash(_i0)
            _h = 5 * _h + Ice.getHash(self.bits)
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.hash)
            _h = 5 * _h + Ice.getHash(self.reason)
            _h = 5 * _h + Ice.getHash(self.start)
            _h = 5 * _h + Ice.getHash(self.duration)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.Ban):
                return NotImplemented
            else:
                if self.address is None or other.address is None:
                    if self.address != other.address:
                        return (-1 if self.address is None else 1)
                else:
                    if self.address < other.address:
                        return -1
                    elif self.address > other.address:
                        return 1
                if self.bits is None or other.bits is None:
                    if self.bits != other.bits:
                        return (-1 if self.bits is None else 1)
                else:
                    if self.bits < other.bits:
                        return -1
                    elif self.bits > other.bits:
                        return 1
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.hash is None or other.hash is None:
                    if self.hash != other.hash:
                        return (-1 if self.hash is None else 1)
                else:
                    if self.hash < other.hash:
                        return -1
                    elif self.hash > other.hash:
                        return 1
                if self.reason is None or other.reason is None:
                    if self.reason != other.reason:
                        return (-1 if self.reason is None else 1)
                else:
                    if self.reason < other.reason:
                        return -1
                    elif self.reason > other.reason:
                        return 1
                if self.start is None or other.start is None:
                    if self.start != other.start:
                        return (-1 if self.start is None else 1)
                else:
                    if self.start < other.start:
                        return -1
                    elif self.start > other.start:
                        return 1
                if self.duration is None or other.duration is None:
                    if self.duration != other.duration:
                        return (-1 if self.duration is None else 1)
                else:
                    if self.duration < other.duration:
                        return -1
                    elif self.duration > other.duration:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Ban)

        __repr__ = __str__

    _M_Murmur._t_Ban = IcePy.defineStruct('::Murmur::Ban', Ban, (), (
        ('address', (), _M_Murmur._t_NetAddress),
        ('bits', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('hash', (), IcePy._t_string),
        ('reason', (), IcePy._t_string),
        ('start', (), IcePy._t_int),
        ('duration', (), IcePy._t_int)
    ))

    _M_Murmur.Ban = Ban
    del Ban

if 'LogEntry' not in _M_Murmur.__dict__:
    _M_Murmur.LogEntry = Ice.createTempClass()
    class LogEntry(object):
        '''A entry in the log.'''
        def __init__(self, timestamp=0, txt=''):
            self.timestamp = timestamp
            self.txt = txt

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.timestamp)
            _h = 5 * _h + Ice.getHash(self.txt)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.LogEntry):
                return NotImplemented
            else:
                if self.timestamp is None or other.timestamp is None:
                    if self.timestamp != other.timestamp:
                        return (-1 if self.timestamp is None else 1)
                else:
                    if self.timestamp < other.timestamp:
                        return -1
                    elif self.timestamp > other.timestamp:
                        return 1
                if self.txt is None or other.txt is None:
                    if self.txt != other.txt:
                        return (-1 if self.txt is None else 1)
                else:
                    if self.txt < other.txt:
                        return -1
                    elif self.txt > other.txt:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_LogEntry)

        __repr__ = __str__

    _M_Murmur._t_LogEntry = IcePy.defineStruct('::Murmur::LogEntry', LogEntry, (), (
        ('timestamp', (), IcePy._t_int),
        ('txt', (), IcePy._t_string)
    ))

    _M_Murmur.LogEntry = LogEntry
    del LogEntry

if 'Tree' not in _M_Murmur.__dict__:
    _M_Murmur._t_Tree = IcePy.declareClass('::Murmur::Tree')
    _M_Murmur._t_TreePrx = IcePy.declareProxy('::Murmur::Tree')

if '_t_TreeList' not in _M_Murmur.__dict__:
    _M_Murmur._t_TreeList = IcePy.defineSequence('::Murmur::TreeList', (), _M_Murmur._t_Tree)

if 'ChannelInfo' not in _M_Murmur.__dict__:
    _M_Murmur.ChannelInfo = Ice.createTempClass()
    class ChannelInfo(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    ChannelInfo.ChannelDescription = ChannelInfo("ChannelDescription", 0)
    ChannelInfo.ChannelPosition = ChannelInfo("ChannelPosition", 1)
    ChannelInfo._enumerators = { 0:ChannelInfo.ChannelDescription, 1:ChannelInfo.ChannelPosition }

    _M_Murmur._t_ChannelInfo = IcePy.defineEnum('::Murmur::ChannelInfo', ChannelInfo, (), ChannelInfo._enumerators)

    _M_Murmur.ChannelInfo = ChannelInfo
    del ChannelInfo

if 'UserInfo' not in _M_Murmur.__dict__:
    _M_Murmur.UserInfo = Ice.createTempClass()
    class UserInfo(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    UserInfo.UserName = UserInfo("UserName", 0)
    UserInfo.UserEmail = UserInfo("UserEmail", 1)
    UserInfo.UserComment = UserInfo("UserComment", 2)
    UserInfo.UserHash = UserInfo("UserHash", 3)
    UserInfo.UserPassword = UserInfo("UserPassword", 4)
    UserInfo.UserLastActive = UserInfo("UserLastActive", 5)
    UserInfo._enumerators = { 0:UserInfo.UserName, 1:UserInfo.UserEmail, 2:UserInfo.UserComment, 3:UserInfo.UserHash, 4:UserInfo.UserPassword, 5:UserInfo.UserLastActive }

    _M_Murmur._t_UserInfo = IcePy.defineEnum('::Murmur::UserInfo', UserInfo, (), UserInfo._enumerators)

    _M_Murmur.UserInfo = UserInfo
    del UserInfo

if '_t_UserMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_UserMap = IcePy.defineDictionary('::Murmur::UserMap', (), IcePy._t_int, _M_Murmur._t_User)

if '_t_ChannelMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_ChannelMap = IcePy.defineDictionary('::Murmur::ChannelMap', (), IcePy._t_int, _M_Murmur._t_Channel)

if '_t_ChannelList' not in _M_Murmur.__dict__:
    _M_Murmur._t_ChannelList = IcePy.defineSequence('::Murmur::ChannelList', (), _M_Murmur._t_Channel)

if '_t_UserList' not in _M_Murmur.__dict__:
    _M_Murmur._t_UserList = IcePy.defineSequence('::Murmur::UserList', (), _M_Murmur._t_User)

if '_t_GroupList' not in _M_Murmur.__dict__:
    _M_Murmur._t_GroupList = IcePy.defineSequence('::Murmur::GroupList', (), _M_Murmur._t_Group)

if '_t_ACLList' not in _M_Murmur.__dict__:
    _M_Murmur._t_ACLList = IcePy.defineSequence('::Murmur::ACLList', (), _M_Murmur._t_ACL)

if '_t_LogList' not in _M_Murmur.__dict__:
    _M_Murmur._t_LogList = IcePy.defineSequence('::Murmur::LogList', (), _M_Murmur._t_LogEntry)

if '_t_BanList' not in _M_Murmur.__dict__:
    _M_Murmur._t_BanList = IcePy.defineSequence('::Murmur::BanList', (), _M_Murmur._t_Ban)

if '_t_IdList' not in _M_Murmur.__dict__:
    _M_Murmur._t_IdList = IcePy.defineSequence('::Murmur::IdList', (), IcePy._t_int)

if '_t_NameList' not in _M_Murmur.__dict__:
    _M_Murmur._t_NameList = IcePy.defineSequence('::Murmur::NameList', (), IcePy._t_string)

if '_t_NameMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_NameMap = IcePy.defineDictionary('::Murmur::NameMap', (), IcePy._t_int, IcePy._t_string)

if '_t_IdMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_IdMap = IcePy.defineDictionary('::Murmur::IdMap', (), IcePy._t_string, IcePy._t_int)

if '_t_Texture' not in _M_Murmur.__dict__:
    _M_Murmur._t_Texture = IcePy.defineSequence('::Murmur::Texture', (), IcePy._t_byte)

if '_t_ConfigMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_ConfigMap = IcePy.defineDictionary('::Murmur::ConfigMap', (), IcePy._t_string, IcePy._t_string)

if '_t_GroupNameList' not in _M_Murmur.__dict__:
    _M_Murmur._t_GroupNameList = IcePy.defineSequence('::Murmur::GroupNameList', (), IcePy._t_string)

if '_t_CertificateDer' not in _M_Murmur.__dict__:
    _M_Murmur._t_CertificateDer = IcePy.defineSequence('::Murmur::CertificateDer', (), IcePy._t_byte)

if '_t_CertificateList' not in _M_Murmur.__dict__:
    _M_Murmur._t_CertificateList = IcePy.defineSequence('::Murmur::CertificateList', (), _M_Murmur._t_CertificateDer)

if '_t_UserInfoMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_UserInfoMap = IcePy.defineDictionary('::Murmur::UserInfoMap', (), _M_Murmur._t_UserInfo, IcePy._t_string)

if 'Tree' not in _M_Murmur.__dict__:
    _M_Murmur.Tree = Ice.createTempClass()
    class Tree(Ice.Object):
        '''User and subchannel state. Read-only.'''
        def __init__(self, c=Ice._struct_marker, children=None, users=None):
            if c is Ice._struct_marker:
                self.c = _M_Murmur.Channel()
            else:
                self.c = c
            self.children = children
            self.users = users

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::Tree')

        def ice_id(self, current=None):
            return '::Murmur::Tree'

        def ice_staticId():
            return '::Murmur::Tree'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Tree)

        __repr__ = __str__

    _M_Murmur.TreePrx = Ice.createTempClass()
    class TreePrx(Ice.ObjectPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.TreePrx.ice_checkedCast(proxy, '::Murmur::Tree', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.TreePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::Murmur::Tree'
        ice_staticId = staticmethod(ice_staticId)

    _M_Murmur._t_TreePrx = IcePy.defineProxy('::Murmur::Tree', TreePrx)

    _M_Murmur._t_Tree = IcePy.defineClass('::Murmur::Tree', Tree, -1, (), False, False, None, (), (
        ('c', (), _M_Murmur._t_Channel, False, 0),
        ('children', (), _M_Murmur._t_TreeList, False, 0),
        ('users', (), _M_Murmur._t_UserList, False, 0)
    ))
    Tree._ice_type = _M_Murmur._t_Tree

    _M_Murmur.Tree = Tree
    del Tree

    _M_Murmur.TreePrx = TreePrx
    del TreePrx

if 'MurmurException' not in _M_Murmur.__dict__:
    _M_Murmur.MurmurException = Ice.createTempClass()
    class MurmurException(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::MurmurException'

    _M_Murmur._t_MurmurException = IcePy.defineException('::Murmur::MurmurException', MurmurException, (), False, None, ())
    MurmurException._ice_type = _M_Murmur._t_MurmurException

    _M_Murmur.MurmurException = MurmurException
    del MurmurException

if 'InvalidSessionException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidSessionException = Ice.createTempClass()
    class InvalidSessionException(_M_Murmur.MurmurException):
        '''This is thrown when you specify an invalid session. This may happen if the user has disconnected since your last call to Server.getUsers. See User.session'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidSessionException'

    _M_Murmur._t_InvalidSessionException = IcePy.defineException('::Murmur::InvalidSessionException', InvalidSessionException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidSessionException._ice_type = _M_Murmur._t_InvalidSessionException

    _M_Murmur.InvalidSessionException = InvalidSessionException
    del InvalidSessionException

if 'InvalidChannelException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidChannelException = Ice.createTempClass()
    class InvalidChannelException(_M_Murmur.MurmurException):
        '''This is thrown when you specify an invalid channel id. This may happen if the channel was removed by another provess. It can also be thrown if you try to add an invalid channel.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidChannelException'

    _M_Murmur._t_InvalidChannelException = IcePy.defineException('::Murmur::InvalidChannelException', InvalidChannelException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidChannelException._ice_type = _M_Murmur._t_InvalidChannelException

    _M_Murmur.InvalidChannelException = InvalidChannelException
    del InvalidChannelException

if 'InvalidServerException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidServerException = Ice.createTempClass()
    class InvalidServerException(_M_Murmur.MurmurException):
        '''This is thrown when you try to do an operation on a server that does not exist. This may happen if someone has removed the server.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidServerException'

    _M_Murmur._t_InvalidServerException = IcePy.defineException('::Murmur::InvalidServerException', InvalidServerException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidServerException._ice_type = _M_Murmur._t_InvalidServerException

    _M_Murmur.InvalidServerException = InvalidServerException
    del InvalidServerException

if 'ServerBootedException' not in _M_Murmur.__dict__:
    _M_Murmur.ServerBootedException = Ice.createTempClass()
    class ServerBootedException(_M_Murmur.MurmurException):
        '''This happens if you try to fetch user or channel state on a stopped server, if you try to stop an already stopped server or start an already started server.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::ServerBootedException'

    _M_Murmur._t_ServerBootedException = IcePy.defineException('::Murmur::ServerBootedException', ServerBootedException, (), False, _M_Murmur._t_MurmurException, ())
    ServerBootedException._ice_type = _M_Murmur._t_ServerBootedException

    _M_Murmur.ServerBootedException = ServerBootedException
    del ServerBootedException

if 'ServerFailureException' not in _M_Murmur.__dict__:
    _M_Murmur.ServerFailureException = Ice.createTempClass()
    class ServerFailureException(_M_Murmur.MurmurException):
        '''This is thrown if Server.start fails, and should generally be the cause for some concern.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::ServerFailureException'

    _M_Murmur._t_ServerFailureException = IcePy.defineException('::Murmur::ServerFailureException', ServerFailureException, (), False, _M_Murmur._t_MurmurException, ())
    ServerFailureException._ice_type = _M_Murmur._t_ServerFailureException

    _M_Murmur.ServerFailureException = ServerFailureException
    del ServerFailureException

if 'InvalidUserException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidUserException = Ice.createTempClass()
    class InvalidUserException(_M_Murmur.MurmurException):
        '''This is thrown when you specify an invalid userid.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidUserException'

    _M_Murmur._t_InvalidUserException = IcePy.defineException('::Murmur::InvalidUserException', InvalidUserException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidUserException._ice_type = _M_Murmur._t_InvalidUserException

    _M_Murmur.InvalidUserException = InvalidUserException
    del InvalidUserException

if 'InvalidTextureException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidTextureException = Ice.createTempClass()
    class InvalidTextureException(_M_Murmur.MurmurException):
        '''This is thrown when you try to set an invalid texture.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidTextureException'

    _M_Murmur._t_InvalidTextureException = IcePy.defineException('::Murmur::InvalidTextureException', InvalidTextureException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidTextureException._ice_type = _M_Murmur._t_InvalidTextureException

    _M_Murmur.InvalidTextureException = InvalidTextureException
    del InvalidTextureException

if 'InvalidCallbackException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidCallbackException = Ice.createTempClass()
    class InvalidCallbackException(_M_Murmur.MurmurException):
        '''This is thrown when you supply an invalid callback.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidCallbackException'

    _M_Murmur._t_InvalidCallbackException = IcePy.defineException('::Murmur::InvalidCallbackException', InvalidCallbackException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidCallbackException._ice_type = _M_Murmur._t_InvalidCallbackException

    _M_Murmur.InvalidCallbackException = InvalidCallbackException
    del InvalidCallbackException

if 'InvalidSecretException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidSecretException = Ice.createTempClass()
    class InvalidSecretException(_M_Murmur.MurmurException):
        '''This is thrown when you supply the wrong secret in the calling context.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidSecretException'

    _M_Murmur._t_InvalidSecretException = IcePy.defineException('::Murmur::InvalidSecretException', InvalidSecretException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidSecretException._ice_type = _M_Murmur._t_InvalidSecretException

    _M_Murmur.InvalidSecretException = InvalidSecretException
    del InvalidSecretException

if 'NestingLimitException' not in _M_Murmur.__dict__:
    _M_Murmur.NestingLimitException = Ice.createTempClass()
    class NestingLimitException(_M_Murmur.MurmurException):
        '''This is thrown when the channel operation would excede the channel nesting limit'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::NestingLimitException'

    _M_Murmur._t_NestingLimitException = IcePy.defineException('::Murmur::NestingLimitException', NestingLimitException, (), False, _M_Murmur._t_MurmurException, ())
    NestingLimitException._ice_type = _M_Murmur._t_NestingLimitException

    _M_Murmur.NestingLimitException = NestingLimitException
    del NestingLimitException

if 'ServerCallback' not in _M_Murmur.__dict__:
    _M_Murmur.ServerCallback = Ice.createTempClass()
    class ServerCallback(Ice.Object):
        '''Callback interface for servers. You can supply an implementation of this to receive notification
messages from the server.
If an added callback ever throws an exception or goes away, it will be automatically removed.
Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
complete before continuing processing.
Note that callbacks are removed when a server is stopped, so you should have a callback for
MetaCallback.started which calls Server.addCallback.'''
        def __init__(self):
            if Ice.getType(self) == _M_Murmur.ServerCallback:
                raise RuntimeError('Murmur.ServerCallback is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerCallback')

        def ice_id(self, current=None):
            return '::Murmur::ServerCallback'

        def ice_staticId():
            return '::Murmur::ServerCallback'
        ice_staticId = staticmethod(ice_staticId)

        def userConnected(self, state, current=None):
            '''Called when a user connects to the server. 
Arguments:
    state State of connected user.'''
            pass

        def userDisconnected(self, state, current=None):
            '''Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
to retrieve the user's state.
Arguments:
    state State of disconnected user.'''
            pass

        def userStateChanged(self, state, current=None):
            '''Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
Arguments:
    state New state of user.'''
            pass

        def userTextMessage(self, state, message, current=None):
            '''Called when user writes a text message
Arguments:
    state the User sending the message
    message the TextMessage the user has sent'''
            pass

        def channelCreated(self, state, current=None):
            '''Called when a new channel is created. 
Arguments:
    state State of new channel.'''
            pass

        def channelRemoved(self, state, current=None):
            '''Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
Arguments:
    state State of removed channel.'''
            pass

        def channelStateChanged(self, state, current=None):
            '''Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
Arguments:
    state New state of channel.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerCallback)

        __repr__ = __str__

    _M_Murmur.ServerCallbackPrx = Ice.createTempClass()
    class ServerCallbackPrx(Ice.ObjectPrx):

        '''Called when a user connects to the server. 
Arguments:
    state State of connected user.'''
        def userConnected(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_userConnected.invoke(self, ((state, ), _ctx))

        '''Called when a user connects to the server. 
Arguments:
    state State of connected user.'''
        def begin_userConnected(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_userConnected.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a user connects to the server. 
Arguments:
    state State of connected user.'''
        def end_userConnected(self, _r):
            return _M_Murmur.ServerCallback._op_userConnected.end(self, _r)

        '''Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
to retrieve the user's state.
Arguments:
    state State of disconnected user.'''
        def userDisconnected(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_userDisconnected.invoke(self, ((state, ), _ctx))

        '''Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
to retrieve the user's state.
Arguments:
    state State of disconnected user.'''
        def begin_userDisconnected(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_userDisconnected.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
to retrieve the user's state.
Arguments:
    state State of disconnected user.'''
        def end_userDisconnected(self, _r):
            return _M_Murmur.ServerCallback._op_userDisconnected.end(self, _r)

        '''Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
Arguments:
    state New state of user.'''
        def userStateChanged(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_userStateChanged.invoke(self, ((state, ), _ctx))

        '''Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
Arguments:
    state New state of user.'''
        def begin_userStateChanged(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_userStateChanged.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
Arguments:
    state New state of user.'''
        def end_userStateChanged(self, _r):
            return _M_Murmur.ServerCallback._op_userStateChanged.end(self, _r)

        '''Called when user writes a text message
Arguments:
    state the User sending the message
    message the TextMessage the user has sent'''
        def userTextMessage(self, state, message, _ctx=None):
            return _M_Murmur.ServerCallback._op_userTextMessage.invoke(self, ((state, message), _ctx))

        '''Called when user writes a text message
Arguments:
    state the User sending the message
    message the TextMessage the user has sent'''
        def begin_userTextMessage(self, state, message, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_userTextMessage.begin(self, ((state, message), _response, _ex, _sent, _ctx))

        '''Called when user writes a text message
Arguments:
    state the User sending the message
    message the TextMessage the user has sent'''
        def end_userTextMessage(self, _r):
            return _M_Murmur.ServerCallback._op_userTextMessage.end(self, _r)

        '''Called when a new channel is created. 
Arguments:
    state State of new channel.'''
        def channelCreated(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelCreated.invoke(self, ((state, ), _ctx))

        '''Called when a new channel is created. 
Arguments:
    state State of new channel.'''
        def begin_channelCreated(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelCreated.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a new channel is created. 
Arguments:
    state State of new channel.'''
        def end_channelCreated(self, _r):
            return _M_Murmur.ServerCallback._op_channelCreated.end(self, _r)

        '''Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
Arguments:
    state State of removed channel.'''
        def channelRemoved(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelRemoved.invoke(self, ((state, ), _ctx))

        '''Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
Arguments:
    state State of removed channel.'''
        def begin_channelRemoved(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelRemoved.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
Arguments:
    state State of removed channel.'''
        def end_channelRemoved(self, _r):
            return _M_Murmur.ServerCallback._op_channelRemoved.end(self, _r)

        '''Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
Arguments:
    state New state of channel.'''
        def channelStateChanged(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelStateChanged.invoke(self, ((state, ), _ctx))

        '''Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
Arguments:
    state New state of channel.'''
        def begin_channelStateChanged(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelStateChanged.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
Arguments:
    state New state of channel.'''
        def end_channelStateChanged(self, _r):
            return _M_Murmur.ServerCallback._op_channelStateChanged.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerCallbackPrx.ice_checkedCast(proxy, '::Murmur::ServerCallback', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerCallbackPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::Murmur::ServerCallback'
        ice_staticId = staticmethod(ice_staticId)

    _M_Murmur._t_ServerCallbackPrx = IcePy.defineProxy('::Murmur::ServerCallback', ServerCallbackPrx)

    _M_Murmur._t_ServerCallback = IcePy.defineClass('::Murmur::ServerCallback', ServerCallback, -1, (), True, False, None, (), ())
    ServerCallback._ice_type = _M_Murmur._t_ServerCallback

    ServerCallback._op_userConnected = IcePy.Operation('userConnected', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_User, False, 0),), (), None, ())
    ServerCallback._op_userDisconnected = IcePy.Operation('userDisconnected', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_User, False, 0),), (), None, ())
    ServerCallback._op_userStateChanged = IcePy.Operation('userStateChanged', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_User, False, 0),), (), None, ())
    ServerCallback._op_userTextMessage = IcePy.Operation('userTextMessage', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_User, False, 0), ((), _M_Murmur._t_TextMessage, False, 0)), (), None, ())
    ServerCallback._op_channelCreated = IcePy.Operation('channelCreated', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_Channel, False, 0),), (), None, ())
    ServerCallback._op_channelRemoved = IcePy.Operation('channelRemoved', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_Channel, False, 0),), (), None, ())
    ServerCallback._op_channelStateChanged = IcePy.Operation('channelStateChanged', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_Channel, False, 0),), (), None, ())

    _M_Murmur.ServerCallback = ServerCallback
    del ServerCallback

    _M_Murmur.ServerCallbackPrx = ServerCallbackPrx
    del ServerCallbackPrx

_M_Murmur.ContextServer = 1

_M_Murmur.ContextChannel = 2

_M_Murmur.ContextUser = 4

if 'ServerContextCallback' not in _M_Murmur.__dict__:
    _M_Murmur.ServerContextCallback = Ice.createTempClass()
    class ServerContextCallback(Ice.Object):
        '''Callback interface for context actions. You need to supply one of these for Server.addContext. 
If an added callback ever throws an exception or goes away, it will be automatically removed.
Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
complete before continuing processing.'''
        def __init__(self):
            if Ice.getType(self) == _M_Murmur.ServerContextCallback:
                raise RuntimeError('Murmur.ServerContextCallback is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerContextCallback')

        def ice_id(self, current=None):
            return '::Murmur::ServerContextCallback'

        def ice_staticId():
            return '::Murmur::ServerContextCallback'
        ice_staticId = staticmethod(ice_staticId)

        def contextAction(self, action, usr, session, channelid, current=None):
            '''Called when a context action is performed.
Arguments:
    action Action to be performed.
    usr User which initiated the action.
    session If nonzero, session of target user.
    channelid If nonzero, session of target channel.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerContextCallback)

        __repr__ = __str__

    _M_Murmur.ServerContextCallbackPrx = Ice.createTempClass()
    class ServerContextCallbackPrx(Ice.ObjectPrx):

        '''Called when a context action is performed.
Arguments:
    action Action to be performed.
    usr User which initiated the action.
    session If nonzero, session of target user.
    channelid If nonzero, session of target channel.'''
        def contextAction(self, action, usr, session, channelid, _ctx=None):
            return _M_Murmur.ServerContextCallback._op_contextAction.invoke(self, ((action, usr, session, channelid), _ctx))

        '''Called when a context action is performed.
Arguments:
    action Action to be performed.
    usr User which initiated the action.
    session If nonzero, session of target user.
    channelid If nonzero, session of target channel.'''
        def begin_contextAction(self, action, usr, session, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerContextCallback._op_contextAction.begin(self, ((action, usr, session, channelid), _response, _ex, _sent, _ctx))

        '''Called when a context action is performed.
Arguments:
    action Action to be performed.
    usr User which initiated the action.
    session If nonzero, session of target user.
    channelid If nonzero, session of target channel.'''
        def end_contextAction(self, _r):
            return _M_Murmur.ServerContextCallback._op_contextAction.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerContextCallbackPrx.ice_checkedCast(proxy, '::Murmur::ServerContextCallback', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerContextCallbackPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::Murmur::ServerContextCallback'
        ice_staticId = staticmethod(ice_staticId)

    _M_Murmur._t_ServerContextCallbackPrx = IcePy.defineProxy('::Murmur::ServerContextCallback', ServerContextCallbackPrx)

    _M_Murmur._t_ServerContextCallback = IcePy.defineClass('::Murmur::ServerContextCallback', ServerContextCallback, -1, (), True, False, None, (), ())
    ServerContextCallback._ice_type = _M_Murmur._t_ServerContextCallback

    ServerContextCallback._op_contextAction = IcePy.Operation('contextAction', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_Murmur._t_User, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), None, ())

    _M_Murmur.ServerContextCallback = ServerContextCallback
    del ServerContextCallback

    _M_Murmur.ServerContextCallbackPrx = ServerContextCallbackPrx
    del ServerContextCallbackPrx

if 'ServerAuthenticator' not in _M_Murmur.__dict__:
    _M_Murmur.ServerAuthenticator = Ice.createTempClass()
    class ServerAuthenticator(Ice.Object):
        '''Callback interface for server authentication. You need to supply one of these for Server.setAuthenticator.
If an added callback ever throws an exception or goes away, it will be automatically removed.
Please note that unlike ServerCallback and ServerContextCallback, these methods are called
synchronously. If the response lags, the entire murmur server will lag.
Also note that, as the method calls are synchronous, making a call to Server or Meta will
deadlock the server.'''
        def __init__(self):
            if Ice.getType(self) == _M_Murmur.ServerAuthenticator:
                raise RuntimeError('Murmur.ServerAuthenticator is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerAuthenticator')

        def ice_id(self, current=None):
            return '::Murmur::ServerAuthenticator'

        def ice_staticId():
            return '::Murmur::ServerAuthenticator'
        ice_staticId = staticmethod(ice_staticId)

        def authenticate(self, name, pw, certificates, certhash, certstrong, current=None):
            '''Called to authenticate a user. If you do not know the username in question, always return -2 from this
method to fall through to normal database authentication.
Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
the username and id so it cannot be used for normal database authentication.
The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
should only be trusted if certstrong is true.

Arguments:
    name Username to authenticate.
    pw Password to authenticate with.
    certificates List of der encoded certificates the user connected with.
    certhash Hash of user certificate, as used by murmur internally when matching.
    certstrong True if certificate was valid and signed by a trusted CA.
    newname Set this to change the username from the supplied one.
    groups List of groups on the root channel that the user will be added to for the duration of the connection.
Returns:
    UserID of authenticated user, -1 for authentication failures and -2 for unknown user (fallthrough).'''
            pass

        def getInfo(self, id, current=None):
            '''Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
want murmur to take care of this information itself, simply return false to fall through.
Arguments:
    id User id.
    info Information about user. This needs to include at least "name".
Returns:
    true if information is present, false to fall through.'''
            pass

        def nameToId(self, name, current=None):
            '''Map a name to a user id.
Arguments:
    name Username to map.
Returns:
    User id or -2 for unknown name.'''
            pass

        def idToName(self, id, current=None):
            '''Map a user id to a username.
Arguments:
    id User id to map.
Returns:
    Name of user or empty string for unknown id.'''
            pass

        def idToTexture(self, id, current=None):
            '''Map a user to a custom Texture.
Arguments:
    id User id to map.
Returns:
    User texture or an empty texture for unknwon users or users without textures.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerAuthenticator)

        __repr__ = __str__

    _M_Murmur.ServerAuthenticatorPrx = Ice.createTempClass()
    class ServerAuthenticatorPrx(Ice.ObjectPrx):

        '''Called to authenticate a user. If you do not know the username in question, always return -2 from this
method to fall through to normal database authentication.
Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
the username and id so it cannot be used for normal database authentication.
The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
should only be trusted if certstrong is true.

Arguments:
    name Username to authenticate.
    pw Password to authenticate with.
    certificates List of der encoded certificates the user connected with.
    certhash Hash of user certificate, as used by murmur internally when matching.
    certstrong True if certificate was valid and signed by a trusted CA.
    newname Set this to change the username from the supplied one.
    groups List of groups on the root channel that the user will be added to for the duration of the connection.
Returns:
    UserID of authenticated user, -1 for authentication failures and -2 for unknown user (fallthrough).'''
        def authenticate(self, name, pw, certificates, certhash, certstrong, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_authenticate.invoke(self, ((name, pw, certificates, certhash, certstrong), _ctx))

        '''Called to authenticate a user. If you do not know the username in question, always return -2 from this
method to fall through to normal database authentication.
Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
the username and id so it cannot be used for normal database authentication.
The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
should only be trusted if certstrong is true.

Arguments:
    name Username to authenticate.
    pw Password to authenticate with.
    certificates List of der encoded certificates the user connected with.
    certhash Hash of user certificate, as used by murmur internally when matching.
    certstrong True if certificate was valid and signed by a trusted CA.
    newname Set this to change the username from the supplied one.
    groups List of groups on the root channel that the user will be added to for the duration of the connection.
Returns:
    UserID of authenticated user, -1 for authentication failures and -2 for unknown user (fallthrough).'''
        def begin_authenticate(self, name, pw, certificates, certhash, certstrong, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_authenticate.begin(self, ((name, pw, certificates, certhash, certstrong), _response, _ex, _sent, _ctx))

        '''Called to authenticate a user. If you do not know the username in question, always return -2 from this
method to fall through to normal database authentication.
Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
the username and id so it cannot be used for normal database authentication.
The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
should only be trusted if certstrong is true.

Arguments:
    name Username to authenticate.
    pw Password to authenticate with.
    certificates List of der encoded certificates the user connected with.
    certhash Hash of user certificate, as used by murmur internally when matching.
    certstrong True if certificate was valid and signed by a trusted CA.
    newname Set this to change the username from the supplied one.
    groups List of groups on the root channel that the user will be added to for the duration of the connection.
Returns:
    UserID of authenticated user, -1 for authentication failures and -2 for unknown user (fallthrough).'''
        def end_authenticate(self, _r):
            return _M_Murmur.ServerAuthenticator._op_authenticate.end(self, _r)

        '''Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
want murmur to take care of this information itself, simply return false to fall through.
Arguments:
    id User id.
    info Information about user. This needs to include at least "name".
Returns:
    true if information is present, false to fall through.'''
        def getInfo(self, id, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_getInfo.invoke(self, ((id, ), _ctx))

        '''Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
want murmur to take care of this information itself, simply return false to fall through.
Arguments:
    id User id.
    info Information about user. This needs to include at least "name".
Returns:
    true if information is present, false to fall through.'''
        def begin_getInfo(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_getInfo.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
want murmur to take care of this information itself, simply return false to fall through.
Arguments:
    id User id.
    info Information about user. This needs to include at least "name".
Returns:
    true if information is present, false to fall through.'''
        def end_getInfo(self, _r):
            return _M_Murmur.ServerAuthenticator._op_getInfo.end(self, _r)

        '''Map a name to a user id.
Arguments:
    name Username to map.
Returns:
    User id or -2 for unknown name.'''
        def nameToId(self, name, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_nameToId.invoke(self, ((name, ), _ctx))

        '''Map a name to a user id.
Arguments:
    name Username to map.
Returns:
    User id or -2 for unknown name.'''
        def begin_nameToId(self, name, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_nameToId.begin(self, ((name, ), _response, _ex, _sent, _ctx))

        '''Map a name to a user id.
Arguments:
    name Username to map.
Returns:
    User id or -2 for unknown name.'''
        def end_nameToId(self, _r):
            return _M_Murmur.ServerAuthenticator._op_nameToId.end(self, _r)

        '''Map a user id to a username.
Arguments:
    id User id to map.
Returns:
    Name of user or empty string for unknown id.'''
        def idToName(self, id, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_idToName.invoke(self, ((id, ), _ctx))

        '''Map a user id to a username.
Arguments:
    id User id to map.
Returns:
    Name of user or empty string for unknown id.'''
        def begin_idToName(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_idToName.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Map a user id to a username.
Arguments:
    id User id to map.
Returns:
    Name of user or empty string for unknown id.'''
        def end_idToName(self, _r):
            return _M_Murmur.ServerAuthenticator._op_idToName.end(self, _r)

        '''Map a user to a custom Texture.
Arguments:
    id User id to map.
Returns:
    User texture or an empty texture for unknwon users or users without textures.'''
        def idToTexture(self, id, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.invoke(self, ((id, ), _ctx))

        '''Map a user to a custom Texture.
Arguments:
    id User id to map.
Returns:
    User texture or an empty texture for unknwon users or users without textures.'''
        def begin_idToTexture(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Map a user to a custom Texture.
Arguments:
    id User id to map.
Returns:
    User texture or an empty texture for unknwon users or users without textures.'''
        def end_idToTexture(self, _r):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerAuthenticatorPrx.ice_checkedCast(proxy, '::Murmur::ServerAuthenticator', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerAuthenticatorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::Murmur::ServerAuthenticator'
        ice_staticId = staticmethod(ice_staticId)

    _M_Murmur._t_ServerAuthenticatorPrx = IcePy.defineProxy('::Murmur::ServerAuthenticator', ServerAuthenticatorPrx)

    _M_Murmur._t_ServerAuthenticator = IcePy.defineClass('::Murmur::ServerAuthenticator', ServerAuthenticator, -1, (), True, False, None, (), ())
    ServerAuthenticator._ice_type = _M_Murmur._t_ServerAuthenticator

    ServerAuthenticator._op_authenticate = IcePy.Operation('authenticate', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), _M_Murmur._t_CertificateList, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_bool, False, 0)), (((), IcePy._t_string, False, 0), ((), _M_Murmur._t_GroupNameList, False, 0)), ((), IcePy._t_int, False, 0), ())
    ServerAuthenticator._op_getInfo = IcePy.Operation('getInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0),), (((), _M_Murmur._t_UserInfoMap, False, 0),), ((), IcePy._t_bool, False, 0), ())
    ServerAuthenticator._op_nameToId = IcePy.Operation('nameToId', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_int, False, 0), ())
    ServerAuthenticator._op_idToName = IcePy.Operation('idToName', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0),), (), ((), IcePy._t_string, False, 0), ())
    ServerAuthenticator._op_idToTexture = IcePy.Operation('idToTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_Texture, False, 0), ())

    _M_Murmur.ServerAuthenticator = ServerAuthenticator
    del ServerAuthenticator

    _M_Murmur.ServerAuthenticatorPrx = ServerAuthenticatorPrx
    del ServerAuthenticatorPrx

if 'ServerUpdatingAuthenticator' not in _M_Murmur.__dict__:
    _M_Murmur.ServerUpdatingAuthenticator = Ice.createTempClass()
    class ServerUpdatingAuthenticator(_M_Murmur.ServerAuthenticator):
        '''Callback interface for server authentication and registration. This allows you to support both authentication
and account updating.
You do not need to implement this if all you want is authentication, you only need this if other scripts
connected to the same server calls e.g. Server.setTexture.
Almost all of these methods support fall through, meaning murmur should continue the operation against its
own database.'''
        def __init__(self):
            if Ice.getType(self) == _M_Murmur.ServerUpdatingAuthenticator:
                raise RuntimeError('Murmur.ServerUpdatingAuthenticator is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerAuthenticator', '::Murmur::ServerUpdatingAuthenticator')

        def ice_id(self, current=None):
            return '::Murmur::ServerUpdatingAuthenticator'

        def ice_staticId():
            return '::Murmur::ServerUpdatingAuthenticator'
        ice_staticId = staticmethod(ice_staticId)

        def registerUser(self, info, current=None):
            '''Register a new user.
Arguments:
    info Information about user to register.
Returns:
    User id of new user, -1 for registration failure, or -2 to fall through.'''
            pass

        def unregisterUser(self, id, current=None):
            '''Unregister a user.
Arguments:
    id Userid to unregister.
Returns:
    1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.'''
            pass

        def getRegisteredUsers(self, filter, current=None):
            '''Get a list of registered users matching filter.
Arguments:
    filter Substring usernames must contain. If empty, return all registered users.
Returns:
    List of matching registered users.'''
            pass

        def setInfo(self, id, info, current=None):
            '''Set additional information for user registration.
Arguments:
    id Userid of registered user.
    info Information to set about user. This should be merged with existing information.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
            pass

        def setTexture(self, id, tex, current=None):
            '''Set texture (now called avatar) of user registration.
Arguments:
    id registrationId of registered user.
    tex New texture.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerUpdatingAuthenticator)

        __repr__ = __str__

    _M_Murmur.ServerUpdatingAuthenticatorPrx = Ice.createTempClass()
    class ServerUpdatingAuthenticatorPrx(_M_Murmur.ServerAuthenticatorPrx):

        '''Register a new user.
Arguments:
    info Information about user to register.
Returns:
    User id of new user, -1 for registration failure, or -2 to fall through.'''
        def registerUser(self, info, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.invoke(self, ((info, ), _ctx))

        '''Register a new user.
Arguments:
    info Information about user to register.
Returns:
    User id of new user, -1 for registration failure, or -2 to fall through.'''
        def begin_registerUser(self, info, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.begin(self, ((info, ), _response, _ex, _sent, _ctx))

        '''Register a new user.
Arguments:
    info Information about user to register.
Returns:
    User id of new user, -1 for registration failure, or -2 to fall through.'''
        def end_registerUser(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.end(self, _r)

        '''Unregister a user.
Arguments:
    id Userid to unregister.
Returns:
    1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.'''
        def unregisterUser(self, id, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.invoke(self, ((id, ), _ctx))

        '''Unregister a user.
Arguments:
    id Userid to unregister.
Returns:
    1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.'''
        def begin_unregisterUser(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Unregister a user.
Arguments:
    id Userid to unregister.
Returns:
    1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.'''
        def end_unregisterUser(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.end(self, _r)

        '''Get a list of registered users matching filter.
Arguments:
    filter Substring usernames must contain. If empty, return all registered users.
Returns:
    List of matching registered users.'''
        def getRegisteredUsers(self, filter, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.invoke(self, ((filter, ), _ctx))

        '''Get a list of registered users matching filter.
Arguments:
    filter Substring usernames must contain. If empty, return all registered users.
Returns:
    List of matching registered users.'''
        def begin_getRegisteredUsers(self, filter, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.begin(self, ((filter, ), _response, _ex, _sent, _ctx))

        '''Get a list of registered users matching filter.
Arguments:
    filter Substring usernames must contain. If empty, return all registered users.
Returns:
    List of matching registered users.'''
        def end_getRegisteredUsers(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.end(self, _r)

        '''Set additional information for user registration.
Arguments:
    id Userid of registered user.
    info Information to set about user. This should be merged with existing information.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def setInfo(self, id, info, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.invoke(self, ((id, info), _ctx))

        '''Set additional information for user registration.
Arguments:
    id Userid of registered user.
    info Information to set about user. This should be merged with existing information.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def begin_setInfo(self, id, info, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.begin(self, ((id, info), _response, _ex, _sent, _ctx))

        '''Set additional information for user registration.
Arguments:
    id Userid of registered user.
    info Information to set about user. This should be merged with existing information.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def end_setInfo(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.end(self, _r)

        '''Set texture (now called avatar) of user registration.
Arguments:
    id registrationId of registered user.
    tex New texture.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def setTexture(self, id, tex, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.invoke(self, ((id, tex), _ctx))

        '''Set texture (now called avatar) of user registration.
Arguments:
    id registrationId of registered user.
    tex New texture.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def begin_setTexture(self, id, tex, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.begin(self, ((id, tex), _response, _ex, _sent, _ctx))

        '''Set texture (now called avatar) of user registration.
Arguments:
    id registrationId of registered user.
    tex New texture.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def end_setTexture(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticatorPrx.ice_checkedCast(proxy, '::Murmur::ServerUpdatingAuthenticator', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerUpdatingAuthenticatorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::Murmur::ServerUpdatingAuthenticator'
        ice_staticId = staticmethod(ice_staticId)

    _M_Murmur._t_ServerUpdatingAuthenticatorPrx = IcePy.defineProxy('::Murmur::ServerUpdatingAuthenticator', ServerUpdatingAuthenticatorPrx)

    _M_Murmur._t_ServerUpdatingAuthenticator = IcePy.defineClass('::Murmur::ServerUpdatingAuthenticator', ServerUpdatingAuthenticator, -1, (), True, False, None, (_M_Murmur._t_ServerAuthenticator,), ())
    ServerUpdatingAuthenticator._ice_type = _M_Murmur._t_ServerUpdatingAuthenticator

    ServerUpdatingAuthenticator._op_registerUser = IcePy.Operation('registerUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Murmur._t_UserInfoMap, False, 0),), (), ((), IcePy._t_int, False, 0), ())
    ServerUpdatingAuthenticator._op_unregisterUser = IcePy.Operation('unregisterUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), ((), IcePy._t_int, False, 0), ())
    ServerUpdatingAuthenticator._op_getRegisteredUsers = IcePy.Operation('getRegisteredUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_Murmur._t_NameMap, False, 0), ())
    ServerUpdatingAuthenticator._op_setInfo = IcePy.Operation('setInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_UserInfoMap, False, 0)), (), ((), IcePy._t_int, False, 0), ())
    ServerUpdatingAuthenticator._op_setTexture = IcePy.Operation('setTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_Texture, False, 0)), (), ((), IcePy._t_int, False, 0), ())

    _M_Murmur.ServerUpdatingAuthenticator = ServerUpdatingAuthenticator
    del ServerUpdatingAuthenticator

    _M_Murmur.ServerUpdatingAuthenticatorPrx = ServerUpdatingAuthenticatorPrx
    del ServerUpdatingAuthenticatorPrx

if 'Server' not in _M_Murmur.__dict__:
    _M_Murmur.Server = Ice.createTempClass()
    class Server(Ice.Object):
        '''Per-server interface. This includes all methods for configuring and altering
the state of a single virtual server. You can retrieve a pointer to this interface
from one of the methods in Meta.'''
        def __init__(self):
            if Ice.getType(self) == _M_Murmur.Server:
                raise RuntimeError('Murmur.Server is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::Server')

        def ice_id(self, current=None):
            return '::Murmur::Server'

        def ice_staticId():
            return '::Murmur::Server'
        ice_staticId = staticmethod(ice_staticId)

        def isRunning_async(self, _cb, current=None):
            '''Shows if the server currently running (accepting users).

Returns:
    Run-state of server.'''
            pass

        def start_async(self, _cb, current=None):
            '''Start server.'''
            pass

        def stop_async(self, _cb, current=None):
            '''Stop server.
Note: Server will be restarted on Murmur restart unless explicitly disabled
with setConf("boot", false)'''
            pass

        def delete_async(self, _cb, current=None):
            '''Delete server and all it's configuration.'''
            pass

        def id_async(self, _cb, current=None):
            '''Fetch the server id.

Returns:
    Unique server id.'''
            pass

        def addCallback_async(self, _cb, cb, current=None):
            '''Add a callback. The callback will receive notifications about changes to users and channels.

Arguments:
    cb Callback interface which will receive notifications.'''
            pass

        def removeCallback_async(self, _cb, cb, current=None):
            '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
            pass

        def setAuthenticator_async(self, _cb, auth, current=None):
            '''Set external authenticator. If set, all authentications from clients are forwarded to this
proxy.

Arguments:
    auth Authenticator object to perform subsequent authentications.'''
            pass

        def getConf_async(self, _cb, key, current=None):
            '''Retrieve configuration item.
Arguments:
    key Configuration key.
Returns:
    Configuration value. If this is empty, see Meta.getDefaultConf'''
            pass

        def getAllConf_async(self, _cb, current=None):
            '''Retrieve all configuration items.
Returns:
    All configured values. If a value isn't set here, the value from Meta.getDefaultConf is used.'''
            pass

        def setConf_async(self, _cb, key, value, current=None):
            '''Set a configuration item.
Arguments:
    key Configuration key.
    value Configuration value.'''
            pass

        def setSuperuserPassword_async(self, _cb, pw, current=None):
            '''Set superuser password. This is just a convenience for using updateRegistration on user id 0.
Arguments:
    pw Password.'''
            pass

        def getLog_async(self, _cb, first, last, current=None):
            '''Fetch log entries.
Arguments:
    first Lowest numbered entry to fetch. 0 is the most recent item.
    last Last entry to fetch.
Returns:
    List of log entries.'''
            pass

        def getLogLen_async(self, _cb, current=None):
            '''Fetch length of log
Returns:
    Number of entries in log'''
            pass

        def getUsers_async(self, _cb, current=None):
            '''Fetch all users. This returns all currently connected users on the server.
Returns:
    List of connected users.'''
            pass

        def getChannels_async(self, _cb, current=None):
            '''Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
Returns:
    List of defined channels.'''
            pass

        def getCertificateList_async(self, _cb, session, current=None):
            '''Fetch certificate of user. This returns the complete certificate chain of a user.
Arguments:
    session Connection ID of user. See User.session.
Returns:
    Certificate list of user.'''
            pass

        def getTree_async(self, _cb, current=None):
            '''Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
as a tree. This is primarily used for viewing the state of the server on a webpage.
Returns:
    Recursive tree of all channels and connected users.'''
            pass

        def getBans_async(self, _cb, current=None):
            '''Fetch all current IP bans on the server.
Returns:
    List of bans.'''
            pass

        def setBans_async(self, _cb, bans, current=None):
            '''Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
append to the returned list before calling this method.
Arguments:
    bans List of bans.'''
            pass

        def kickUser_async(self, _cb, session, reason, current=None):
            '''Kick a user. The user is not banned, and is free to rejoin the server.
Arguments:
    session Connection ID of user. See User.session.
    reason Text message to show when user is kicked.'''
            pass

        def getState_async(self, _cb, session, current=None):
            '''Get state of a single connected user. 
Arguments:
    session Connection ID of user. See User.session.
Returns:
    State of connected user.'''
            pass

        def setState_async(self, _cb, state, current=None):
            '''Set user state. You can use this to move, mute and deafen users.
Arguments:
    state User state to set.'''
            pass

        def sendMessage_async(self, _cb, session, text, current=None):
            '''Send text message to a single user.
Arguments:
    session Connection ID of user. See User.session.
    text Message to send.'''
            pass

        def hasPermission_async(self, _cb, session, channelid, perm, current=None):
            '''Check if user is permitted to perform action.
Arguments:
    session Connection ID of user. See User.session.
    channelid ID of Channel. See Channel.id.
    perm Permission bits to check.
Returns:
    true if any of the permissions in perm were set for the user.'''
            pass

        def effectivePermissions_async(self, _cb, session, channelid, current=None):
            '''Return users effective permissions
Arguments:
    session Connection ID of user. See User.session.
    channelid ID of Channel. See Channel.id.
Returns:
    bitfield of allowed actions'''
            pass

        def addContextCallback_async(self, _cb, session, action, text, cb, ctx, current=None):
            '''Add a context callback. This is done per user, and will add a context menu action for the user.

Arguments:
    session Session of user which should receive context entry.
    action Action string, a unique name to associate with the action.
    text Name of action shown to user.
    cb Callback interface which will receive notifications.
    ctx Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.'''
            pass

        def removeContextCallback_async(self, _cb, cb, current=None):
            '''Remove a callback.

Arguments:
    cb Callback interface to be removed. This callback will be removed from all from all users.'''
            pass

        def getChannelState_async(self, _cb, channelid, current=None):
            '''Get state of single channel.
Arguments:
    channelid ID of Channel. See Channel.id.
Returns:
    State of channel.'''
            pass

        def setChannelState_async(self, _cb, state, current=None):
            '''Set state of a single channel. You can use this to move or relink channels.
Arguments:
    state Channel state to set.'''
            pass

        def removeChannel_async(self, _cb, channelid, current=None):
            '''Remove a channel and all its subchannels.
Arguments:
    channelid ID of Channel. See Channel.id.'''
            pass

        def addChannel_async(self, _cb, name, parent, current=None):
            '''Add a new channel.
Arguments:
    name Name of new channel.
    parent Channel ID of parent channel. See Channel.id.
Returns:
    ID of newly created channel.'''
            pass

        def sendMessageChannel_async(self, _cb, channelid, tree, text, current=None):
            '''Send text message to channel or a tree of channels.
Arguments:
    channelid Channel ID of channel to send to. See Channel.id.
    tree If true, the message will be sent to the channel and all its subchannels.
    text Message to send.'''
            pass

        def getACL_async(self, _cb, channelid, current=None):
            '''Retrieve ACLs and Groups on a channel.
Arguments:
    channelid Channel ID of channel to fetch from. See Channel.id.
    acls List of ACLs on the channel. This will include inherited ACLs.
    groups List of groups on the channel. This will include inherited groups.
    inherit Does this channel inherit ACLs from the parent channel?'''
            pass

        def setACL_async(self, _cb, channelid, acls, groups, inherit, current=None):
            '''Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
Arguments:
    channelid Channel ID of channel to fetch from. See Channel.id.
    acls List of ACLs on the channel.
    groups List of groups on the channel.
    inherit Should this channel inherit ACLs from the parent channel?'''
            pass

        def addUserToGroup_async(self, _cb, channelid, session, group, current=None):
            '''Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See Channel.id.
    session Connection ID of user. See User.session.
    group Group name to add to.'''
            pass

        def removeUserFromGroup_async(self, _cb, channelid, session, group, current=None):
            '''Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See Channel.id.
    session Connection ID of user. See User.session.
    group Group name to remove from.'''
            pass

        def redirectWhisperGroup_async(self, _cb, session, source, target, current=None):
            '''Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
To remove a redirect pass an empty target string. This is intended for context groups.
Arguments:
    session Connection ID of user. See User.session.
    source Group name to redirect from.
    target Group name to redirect to.'''
            pass

        def getUserNames_async(self, _cb, ids, current=None):
            '''Map a list of User.userid to a matching name.
Arguments:
    List of ids.
Returns:
    Matching list of names, with an empty string representing invalid or unknown ids.'''
            pass

        def getUserIds_async(self, _cb, names, current=None):
            '''Map a list of user names to a matching id.
Arguments:
    List of names.
@reuturn List of matching ids, with -1 representing invalid or unknown user names.'''
            pass

        def registerUser_async(self, _cb, info, current=None):
            '''Register a new user.
Arguments:
    info Information about new user. Must include at least "name".
Returns:
    The ID of the user. See RegisteredUser.userid.'''
            pass

        def unregisterUser_async(self, _cb, userid, current=None):
            '''Remove a user registration.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.'''
            pass

        def updateRegistration_async(self, _cb, userid, info, current=None):
            '''Update the registration for a user. You can use this to set the email or password of a user,
and can also use it to change the user's name.
Arguments:
    registration Updated registration record.'''
            pass

        def getRegistration_async(self, _cb, userid, current=None):
            '''Fetch registration for a single user.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
Returns:
    Registration record.'''
            pass

        def getRegisteredUsers_async(self, _cb, filter, current=None):
            '''Fetch a group of registered users.
Arguments:
    filter Substring of user name. If blank, will retrieve all registered users.
Returns:
    List of registration records.'''
            pass

        def verifyPassword_async(self, _cb, name, pw, current=None):
            '''Verify the password of a user. You can use this to verify a user's credentials.
Arguments:
    name User name. See RegisteredUser.name.
    pw User password.
Returns:
    User ID of registered user (See RegisteredUser.userid), -1 for failed authentication or -2 for unknown usernames.'''
            pass

        def getTexture_async(self, _cb, userid, current=None):
            '''Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
Returns:
    Custom texture associated with user or an empty texture.'''
            pass

        def setTexture_async(self, _cb, userid, tex, current=None):
            '''Set a user texture (now called avatar).
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
    tex Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.'''
            pass

        def getUptime_async(self, _cb, current=None):
            '''Get virtual server uptime.
Returns:
    Uptime of the virtual server in seconds'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Server)

        __repr__ = __str__

    _M_Murmur.ServerPrx = Ice.createTempClass()
    class ServerPrx(Ice.ObjectPrx):

        '''Shows if the server currently running (accepting users).

Returns:
    Run-state of server.'''
        def isRunning(self, _ctx=None):
            return _M_Murmur.Server._op_isRunning.invoke(self, ((), _ctx))

        '''Shows if the server currently running (accepting users).

Returns:
    Run-state of server.'''
        def begin_isRunning(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_isRunning.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Shows if the server currently running (accepting users).

Returns:
    Run-state of server.'''
        def end_isRunning(self, _r):
            return _M_Murmur.Server._op_isRunning.end(self, _r)

        '''Start server.'''
        def start(self, _ctx=None):
            return _M_Murmur.Server._op_start.invoke(self, ((), _ctx))

        '''Start server.'''
        def begin_start(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_start.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Start server.'''
        def end_start(self, _r):
            return _M_Murmur.Server._op_start.end(self, _r)

        '''Stop server.
Note: Server will be restarted on Murmur restart unless explicitly disabled
with setConf("boot", false)'''
        def stop(self, _ctx=None):
            return _M_Murmur.Server._op_stop.invoke(self, ((), _ctx))

        '''Stop server.
Note: Server will be restarted on Murmur restart unless explicitly disabled
with setConf("boot", false)'''
        def begin_stop(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_stop.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Stop server.
Note: Server will be restarted on Murmur restart unless explicitly disabled
with setConf("boot", false)'''
        def end_stop(self, _r):
            return _M_Murmur.Server._op_stop.end(self, _r)

        '''Delete server and all it's configuration.'''
        def delete(self, _ctx=None):
            return _M_Murmur.Server._op_delete.invoke(self, ((), _ctx))

        '''Delete server and all it's configuration.'''
        def begin_delete(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_delete.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Delete server and all it's configuration.'''
        def end_delete(self, _r):
            return _M_Murmur.Server._op_delete.end(self, _r)

        '''Fetch the server id.

Returns:
    Unique server id.'''
        def id(self, _ctx=None):
            return _M_Murmur.Server._op_id.invoke(self, ((), _ctx))

        '''Fetch the server id.

Returns:
    Unique server id.'''
        def begin_id(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_id.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch the server id.

Returns:
    Unique server id.'''
        def end_id(self, _r):
            return _M_Murmur.Server._op_id.end(self, _r)

        '''Add a callback. The callback will receive notifications about changes to users and channels.

Arguments:
    cb Callback interface which will receive notifications.'''
        def addCallback(self, cb, _ctx=None):
            return _M_Murmur.Server._op_addCallback.invoke(self, ((cb, ), _ctx))

        '''Add a callback. The callback will receive notifications about changes to users and channels.

Arguments:
    cb Callback interface which will receive notifications.'''
        def begin_addCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_addCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Add a callback. The callback will receive notifications about changes to users and channels.

Arguments:
    cb Callback interface which will receive notifications.'''
        def end_addCallback(self, _r):
            return _M_Murmur.Server._op_addCallback.end(self, _r)

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def removeCallback(self, cb, _ctx=None):
            return _M_Murmur.Server._op_removeCallback.invoke(self, ((cb, ), _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def begin_removeCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_removeCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def end_removeCallback(self, _r):
            return _M_Murmur.Server._op_removeCallback.end(self, _r)

        '''Set external authenticator. If set, all authentications from clients are forwarded to this
proxy.

Arguments:
    auth Authenticator object to perform subsequent authentications.'''
        def setAuthenticator(self, auth, _ctx=None):
            return _M_Murmur.Server._op_setAuthenticator.invoke(self, ((auth, ), _ctx))

        '''Set external authenticator. If set, all authentications from clients are forwarded to this
proxy.

Arguments:
    auth Authenticator object to perform subsequent authentications.'''
        def begin_setAuthenticator(self, auth, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setAuthenticator.begin(self, ((auth, ), _response, _ex, _sent, _ctx))

        '''Set external authenticator. If set, all authentications from clients are forwarded to this
proxy.

Arguments:
    auth Authenticator object to perform subsequent authentications.'''
        def end_setAuthenticator(self, _r):
            return _M_Murmur.Server._op_setAuthenticator.end(self, _r)

        '''Retrieve configuration item.
Arguments:
    key Configuration key.
Returns:
    Configuration value. If this is empty, see Meta.getDefaultConf'''
        def getConf(self, key, _ctx=None):
            return _M_Murmur.Server._op_getConf.invoke(self, ((key, ), _ctx))

        '''Retrieve configuration item.
Arguments:
    key Configuration key.
Returns:
    Configuration value. If this is empty, see Meta.getDefaultConf'''
        def begin_getConf(self, key, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getConf.begin(self, ((key, ), _response, _ex, _sent, _ctx))

        '''Retrieve configuration item.
Arguments:
    key Configuration key.
Returns:
    Configuration value. If this is empty, see Meta.getDefaultConf'''
        def end_getConf(self, _r):
            return _M_Murmur.Server._op_getConf.end(self, _r)

        '''Retrieve all configuration items.
Returns:
    All configured values. If a value isn't set here, the value from Meta.getDefaultConf is used.'''
        def getAllConf(self, _ctx=None):
            return _M_Murmur.Server._op_getAllConf.invoke(self, ((), _ctx))

        '''Retrieve all configuration items.
Returns:
    All configured values. If a value isn't set here, the value from Meta.getDefaultConf is used.'''
        def begin_getAllConf(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getAllConf.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieve all configuration items.
Returns:
    All configured values. If a value isn't set here, the value from Meta.getDefaultConf is used.'''
        def end_getAllConf(self, _r):
            return _M_Murmur.Server._op_getAllConf.end(self, _r)

        '''Set a configuration item.
Arguments:
    key Configuration key.
    value Configuration value.'''
        def setConf(self, key, value, _ctx=None):
            return _M_Murmur.Server._op_setConf.invoke(self, ((key, value), _ctx))

        '''Set a configuration item.
Arguments:
    key Configuration key.
    value Configuration value.'''
        def begin_setConf(self, key, value, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setConf.begin(self, ((key, value), _response, _ex, _sent, _ctx))

        '''Set a configuration item.
Arguments:
    key Configuration key.
    value Configuration value.'''
        def end_setConf(self, _r):
            return _M_Murmur.Server._op_setConf.end(self, _r)

        '''Set superuser password. This is just a convenience for using updateRegistration on user id 0.
Arguments:
    pw Password.'''
        def setSuperuserPassword(self, pw, _ctx=None):
            return _M_Murmur.Server._op_setSuperuserPassword.invoke(self, ((pw, ), _ctx))

        '''Set superuser password. This is just a convenience for using updateRegistration on user id 0.
Arguments:
    pw Password.'''
        def begin_setSuperuserPassword(self, pw, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setSuperuserPassword.begin(self, ((pw, ), _response, _ex, _sent, _ctx))

        '''Set superuser password. This is just a convenience for using updateRegistration on user id 0.
Arguments:
    pw Password.'''
        def end_setSuperuserPassword(self, _r):
            return _M_Murmur.Server._op_setSuperuserPassword.end(self, _r)

        '''Fetch log entries.
Arguments:
    first Lowest numbered entry to fetch. 0 is the most recent item.
    last Last entry to fetch.
Returns:
    List of log entries.'''
        def getLog(self, first, last, _ctx=None):
            return _M_Murmur.Server._op_getLog.invoke(self, ((first, last), _ctx))

        '''Fetch log entries.
Arguments:
    first Lowest numbered entry to fetch. 0 is the most recent item.
    last Last entry to fetch.
Returns:
    List of log entries.'''
        def begin_getLog(self, first, last, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getLog.begin(self, ((first, last), _response, _ex, _sent, _ctx))

        '''Fetch log entries.
Arguments:
    first Lowest numbered entry to fetch. 0 is the most recent item.
    last Last entry to fetch.
Returns:
    List of log entries.'''
        def end_getLog(self, _r):
            return _M_Murmur.Server._op_getLog.end(self, _r)

        '''Fetch length of log
Returns:
    Number of entries in log'''
        def getLogLen(self, _ctx=None):
            return _M_Murmur.Server._op_getLogLen.invoke(self, ((), _ctx))

        '''Fetch length of log
Returns:
    Number of entries in log'''
        def begin_getLogLen(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getLogLen.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch length of log
Returns:
    Number of entries in log'''
        def end_getLogLen(self, _r):
            return _M_Murmur.Server._op_getLogLen.end(self, _r)

        '''Fetch all users. This returns all currently connected users on the server.
Returns:
    List of connected users.'''
        def getUsers(self, _ctx=None):
            return _M_Murmur.Server._op_getUsers.invoke(self, ((), _ctx))

        '''Fetch all users. This returns all currently connected users on the server.
Returns:
    List of connected users.'''
        def begin_getUsers(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getUsers.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch all users. This returns all currently connected users on the server.
Returns:
    List of connected users.'''
        def end_getUsers(self, _r):
            return _M_Murmur.Server._op_getUsers.end(self, _r)

        '''Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
Returns:
    List of defined channels.'''
        def getChannels(self, _ctx=None):
            return _M_Murmur.Server._op_getChannels.invoke(self, ((), _ctx))

        '''Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
Returns:
    List of defined channels.'''
        def begin_getChannels(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getChannels.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
Returns:
    List of defined channels.'''
        def end_getChannels(self, _r):
            return _M_Murmur.Server._op_getChannels.end(self, _r)

        '''Fetch certificate of user. This returns the complete certificate chain of a user.
Arguments:
    session Connection ID of user. See User.session.
Returns:
    Certificate list of user.'''
        def getCertificateList(self, session, _ctx=None):
            return _M_Murmur.Server._op_getCertificateList.invoke(self, ((session, ), _ctx))

        '''Fetch certificate of user. This returns the complete certificate chain of a user.
Arguments:
    session Connection ID of user. See User.session.
Returns:
    Certificate list of user.'''
        def begin_getCertificateList(self, session, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getCertificateList.begin(self, ((session, ), _response, _ex, _sent, _ctx))

        '''Fetch certificate of user. This returns the complete certificate chain of a user.
Arguments:
    session Connection ID of user. See User.session.
Returns:
    Certificate list of user.'''
        def end_getCertificateList(self, _r):
            return _M_Murmur.Server._op_getCertificateList.end(self, _r)

        '''Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
as a tree. This is primarily used for viewing the state of the server on a webpage.
Returns:
    Recursive tree of all channels and connected users.'''
        def getTree(self, _ctx=None):
            return _M_Murmur.Server._op_getTree.invoke(self, ((), _ctx))

        '''Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
as a tree. This is primarily used for viewing the state of the server on a webpage.
Returns:
    Recursive tree of all channels and connected users.'''
        def begin_getTree(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getTree.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
as a tree. This is primarily used for viewing the state of the server on a webpage.
Returns:
    Recursive tree of all channels and connected users.'''
        def end_getTree(self, _r):
            return _M_Murmur.Server._op_getTree.end(self, _r)

        '''Fetch all current IP bans on the server.
Returns:
    List of bans.'''
        def getBans(self, _ctx=None):
            return _M_Murmur.Server._op_getBans.invoke(self, ((), _ctx))

        '''Fetch all current IP bans on the server.
Returns:
    List of bans.'''
        def begin_getBans(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getBans.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch all current IP bans on the server.
Returns:
    List of bans.'''
        def end_getBans(self, _r):
            return _M_Murmur.Server._op_getBans.end(self, _r)

        '''Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
append to the returned list before calling this method.
Arguments:
    bans List of bans.'''
        def setBans(self, bans, _ctx=None):
            return _M_Murmur.Server._op_setBans.invoke(self, ((bans, ), _ctx))

        '''Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
append to the returned list before calling this method.
Arguments:
    bans List of bans.'''
        def begin_setBans(self, bans, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setBans.begin(self, ((bans, ), _response, _ex, _sent, _ctx))

        '''Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
append to the returned list before calling this method.
Arguments:
    bans List of bans.'''
        def end_setBans(self, _r):
            return _M_Murmur.Server._op_setBans.end(self, _r)

        '''Kick a user. The user is not banned, and is free to rejoin the server.
Arguments:
    session Connection ID of user. See User.session.
    reason Text message to show when user is kicked.'''
        def kickUser(self, session, reason, _ctx=None):
            return _M_Murmur.Server._op_kickUser.invoke(self, ((session, reason), _ctx))

        '''Kick a user. The user is not banned, and is free to rejoin the server.
Arguments:
    session Connection ID of user. See User.session.
    reason Text message to show when user is kicked.'''
        def begin_kickUser(self, session, reason, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_kickUser.begin(self, ((session, reason), _response, _ex, _sent, _ctx))

        '''Kick a user. The user is not banned, and is free to rejoin the server.
Arguments:
    session Connection ID of user. See User.session.
    reason Text message to show when user is kicked.'''
        def end_kickUser(self, _r):
            return _M_Murmur.Server._op_kickUser.end(self, _r)

        '''Get state of a single connected user. 
Arguments:
    session Connection ID of user. See User.session.
Returns:
    State of connected user.'''
        def getState(self, session, _ctx=None):
            return _M_Murmur.Server._op_getState.invoke(self, ((session, ), _ctx))

        '''Get state of a single connected user. 
Arguments:
    session Connection ID of user. See User.session.
Returns:
    State of connected user.'''
        def begin_getState(self, session, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getState.begin(self, ((session, ), _response, _ex, _sent, _ctx))

        '''Get state of a single connected user. 
Arguments:
    session Connection ID of user. See User.session.
Returns:
    State of connected user.'''
        def end_getState(self, _r):
            return _M_Murmur.Server._op_getState.end(self, _r)

        '''Set user state. You can use this to move, mute and deafen users.
Arguments:
    state User state to set.'''
        def setState(self, state, _ctx=None):
            return _M_Murmur.Server._op_setState.invoke(self, ((state, ), _ctx))

        '''Set user state. You can use this to move, mute and deafen users.
Arguments:
    state User state to set.'''
        def begin_setState(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setState.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Set user state. You can use this to move, mute and deafen users.
Arguments:
    state User state to set.'''
        def end_setState(self, _r):
            return _M_Murmur.Server._op_setState.end(self, _r)

        '''Send text message to a single user.
Arguments:
    session Connection ID of user. See User.session.
    text Message to send.'''
        def sendMessage(self, session, text, _ctx=None):
            return _M_Murmur.Server._op_sendMessage.invoke(self, ((session, text), _ctx))

        '''Send text message to a single user.
Arguments:
    session Connection ID of user. See User.session.
    text Message to send.'''
        def begin_sendMessage(self, session, text, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_sendMessage.begin(self, ((session, text), _response, _ex, _sent, _ctx))

        '''Send text message to a single user.
Arguments:
    session Connection ID of user. See User.session.
    text Message to send.'''
        def end_sendMessage(self, _r):
            return _M_Murmur.Server._op_sendMessage.end(self, _r)

        '''Check if user is permitted to perform action.
Arguments:
    session Connection ID of user. See User.session.
    channelid ID of Channel. See Channel.id.
    perm Permission bits to check.
Returns:
    true if any of the permissions in perm were set for the user.'''
        def hasPermission(self, session, channelid, perm, _ctx=None):
            return _M_Murmur.Server._op_hasPermission.invoke(self, ((session, channelid, perm), _ctx))

        '''Check if user is permitted to perform action.
Arguments:
    session Connection ID of user. See User.session.
    channelid ID of Channel. See Channel.id.
    perm Permission bits to check.
Returns:
    true if any of the permissions in perm were set for the user.'''
        def begin_hasPermission(self, session, channelid, perm, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_hasPermission.begin(self, ((session, channelid, perm), _response, _ex, _sent, _ctx))

        '''Check if user is permitted to perform action.
Arguments:
    session Connection ID of user. See User.session.
    channelid ID of Channel. See Channel.id.
    perm Permission bits to check.
Returns:
    true if any of the permissions in perm were set for the user.'''
        def end_hasPermission(self, _r):
            return _M_Murmur.Server._op_hasPermission.end(self, _r)

        '''Return users effective permissions
Arguments:
    session Connection ID of user. See User.session.
    channelid ID of Channel. See Channel.id.
Returns:
    bitfield of allowed actions'''
        def effectivePermissions(self, session, channelid, _ctx=None):
            return _M_Murmur.Server._op_effectivePermissions.invoke(self, ((session, channelid), _ctx))

        '''Return users effective permissions
Arguments:
    session Connection ID of user. See User.session.
    channelid ID of Channel. See Channel.id.
Returns:
    bitfield of allowed actions'''
        def begin_effectivePermissions(self, session, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_effectivePermissions.begin(self, ((session, channelid), _response, _ex, _sent, _ctx))

        '''Return users effective permissions
Arguments:
    session Connection ID of user. See User.session.
    channelid ID of Channel. See Channel.id.
Returns:
    bitfield of allowed actions'''
        def end_effectivePermissions(self, _r):
            return _M_Murmur.Server._op_effectivePermissions.end(self, _r)

        '''Add a context callback. This is done per user, and will add a context menu action for the user.

Arguments:
    session Session of user which should receive context entry.
    action Action string, a unique name to associate with the action.
    text Name of action shown to user.
    cb Callback interface which will receive notifications.
    ctx Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.'''
        def addContextCallback(self, session, action, text, cb, ctx, _ctx=None):
            return _M_Murmur.Server._op_addContextCallback.invoke(self, ((session, action, text, cb, ctx), _ctx))

        '''Add a context callback. This is done per user, and will add a context menu action for the user.

Arguments:
    session Session of user which should receive context entry.
    action Action string, a unique name to associate with the action.
    text Name of action shown to user.
    cb Callback interface which will receive notifications.
    ctx Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.'''
        def begin_addContextCallback(self, session, action, text, cb, ctx, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_addContextCallback.begin(self, ((session, action, text, cb, ctx), _response, _ex, _sent, _ctx))

        '''Add a context callback. This is done per user, and will add a context menu action for the user.

Arguments:
    session Session of user which should receive context entry.
    action Action string, a unique name to associate with the action.
    text Name of action shown to user.
    cb Callback interface which will receive notifications.
    ctx Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.'''
        def end_addContextCallback(self, _r):
            return _M_Murmur.Server._op_addContextCallback.end(self, _r)

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed. This callback will be removed from all from all users.'''
        def removeContextCallback(self, cb, _ctx=None):
            return _M_Murmur.Server._op_removeContextCallback.invoke(self, ((cb, ), _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed. This callback will be removed from all from all users.'''
        def begin_removeContextCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_removeContextCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed. This callback will be removed from all from all users.'''
        def end_removeContextCallback(self, _r):
            return _M_Murmur.Server._op_removeContextCallback.end(self, _r)

        '''Get state of single channel.
Arguments:
    channelid ID of Channel. See Channel.id.
Returns:
    State of channel.'''
        def getChannelState(self, channelid, _ctx=None):
            return _M_Murmur.Server._op_getChannelState.invoke(self, ((channelid, ), _ctx))

        '''Get state of single channel.
Arguments:
    channelid ID of Channel. See Channel.id.
Returns:
    State of channel.'''
        def begin_getChannelState(self, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getChannelState.begin(self, ((channelid, ), _response, _ex, _sent, _ctx))

        '''Get state of single channel.
Arguments:
    channelid ID of Channel. See Channel.id.
Returns:
    State of channel.'''
        def end_getChannelState(self, _r):
            return _M_Murmur.Server._op_getChannelState.end(self, _r)

        '''Set state of a single channel. You can use this to move or relink channels.
Arguments:
    state Channel state to set.'''
        def setChannelState(self, state, _ctx=None):
            return _M_Murmur.Server._op_setChannelState.invoke(self, ((state, ), _ctx))

        '''Set state of a single channel. You can use this to move or relink channels.
Arguments:
    state Channel state to set.'''
        def begin_setChannelState(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setChannelState.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Set state of a single channel. You can use this to move or relink channels.
Arguments:
    state Channel state to set.'''
        def end_setChannelState(self, _r):
            return _M_Murmur.Server._op_setChannelState.end(self, _r)

        '''Remove a channel and all its subchannels.
Arguments:
    channelid ID of Channel. See Channel.id.'''
        def removeChannel(self, channelid, _ctx=None):
            return _M_Murmur.Server._op_removeChannel.invoke(self, ((channelid, ), _ctx))

        '''Remove a channel and all its subchannels.
Arguments:
    channelid ID of Channel. See Channel.id.'''
        def begin_removeChannel(self, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_removeChannel.begin(self, ((channelid, ), _response, _ex, _sent, _ctx))

        '''Remove a channel and all its subchannels.
Arguments:
    channelid ID of Channel. See Channel.id.'''
        def end_removeChannel(self, _r):
            return _M_Murmur.Server._op_removeChannel.end(self, _r)

        '''Add a new channel.
Arguments:
    name Name of new channel.
    parent Channel ID of parent channel. See Channel.id.
Returns:
    ID of newly created channel.'''
        def addChannel(self, name, parent, _ctx=None):
            return _M_Murmur.Server._op_addChannel.invoke(self, ((name, parent), _ctx))

        '''Add a new channel.
Arguments:
    name Name of new channel.
    parent Channel ID of parent channel. See Channel.id.
Returns:
    ID of newly created channel.'''
        def begin_addChannel(self, name, parent, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_addChannel.begin(self, ((name, parent), _response, _ex, _sent, _ctx))

        '''Add a new channel.
Arguments:
    name Name of new channel.
    parent Channel ID of parent channel. See Channel.id.
Returns:
    ID of newly created channel.'''
        def end_addChannel(self, _r):
            return _M_Murmur.Server._op_addChannel.end(self, _r)

        '''Send text message to channel or a tree of channels.
Arguments:
    channelid Channel ID of channel to send to. See Channel.id.
    tree If true, the message will be sent to the channel and all its subchannels.
    text Message to send.'''
        def sendMessageChannel(self, channelid, tree, text, _ctx=None):
            return _M_Murmur.Server._op_sendMessageChannel.invoke(self, ((channelid, tree, text), _ctx))

        '''Send text message to channel or a tree of channels.
Arguments:
    channelid Channel ID of channel to send to. See Channel.id.
    tree If true, the message will be sent to the channel and all its subchannels.
    text Message to send.'''
        def begin_sendMessageChannel(self, channelid, tree, text, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_sendMessageChannel.begin(self, ((channelid, tree, text), _response, _ex, _sent, _ctx))

        '''Send text message to channel or a tree of channels.
Arguments:
    channelid Channel ID of channel to send to. See Channel.id.
    tree If true, the message will be sent to the channel and all its subchannels.
    text Message to send.'''
        def end_sendMessageChannel(self, _r):
            return _M_Murmur.Server._op_sendMessageChannel.end(self, _r)

        '''Retrieve ACLs and Groups on a channel.
Arguments:
    channelid Channel ID of channel to fetch from. See Channel.id.
    acls List of ACLs on the channel. This will include inherited ACLs.
    groups List of groups on the channel. This will include inherited groups.
    inherit Does this channel inherit ACLs from the parent channel?'''
        def getACL(self, channelid, _ctx=None):
            return _M_Murmur.Server._op_getACL.invoke(self, ((channelid, ), _ctx))

        '''Retrieve ACLs and Groups on a channel.
Arguments:
    channelid Channel ID of channel to fetch from. See Channel.id.
    acls List of ACLs on the channel. This will include inherited ACLs.
    groups List of groups on the channel. This will include inherited groups.
    inherit Does this channel inherit ACLs from the parent channel?'''
        def begin_getACL(self, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getACL.begin(self, ((channelid, ), _response, _ex, _sent, _ctx))

        '''Retrieve ACLs and Groups on a channel.
Arguments:
    channelid Channel ID of channel to fetch from. See Channel.id.
    acls List of ACLs on the channel. This will include inherited ACLs.
    groups List of groups on the channel. This will include inherited groups.
    inherit Does this channel inherit ACLs from the parent channel?'''
        def end_getACL(self, _r):
            return _M_Murmur.Server._op_getACL.end(self, _r)

        '''Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
Arguments:
    channelid Channel ID of channel to fetch from. See Channel.id.
    acls List of ACLs on the channel.
    groups List of groups on the channel.
    inherit Should this channel inherit ACLs from the parent channel?'''
        def setACL(self, channelid, acls, groups, inherit, _ctx=None):
            return _M_Murmur.Server._op_setACL.invoke(self, ((channelid, acls, groups, inherit), _ctx))

        '''Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
Arguments:
    channelid Channel ID of channel to fetch from. See Channel.id.
    acls List of ACLs on the channel.
    groups List of groups on the channel.
    inherit Should this channel inherit ACLs from the parent channel?'''
        def begin_setACL(self, channelid, acls, groups, inherit, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setACL.begin(self, ((channelid, acls, groups, inherit), _response, _ex, _sent, _ctx))

        '''Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
Arguments:
    channelid Channel ID of channel to fetch from. See Channel.id.
    acls List of ACLs on the channel.
    groups List of groups on the channel.
    inherit Should this channel inherit ACLs from the parent channel?'''
        def end_setACL(self, _r):
            return _M_Murmur.Server._op_setACL.end(self, _r)

        '''Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See Channel.id.
    session Connection ID of user. See User.session.
    group Group name to add to.'''
        def addUserToGroup(self, channelid, session, group, _ctx=None):
            return _M_Murmur.Server._op_addUserToGroup.invoke(self, ((channelid, session, group), _ctx))

        '''Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See Channel.id.
    session Connection ID of user. See User.session.
    group Group name to add to.'''
        def begin_addUserToGroup(self, channelid, session, group, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_addUserToGroup.begin(self, ((channelid, session, group), _response, _ex, _sent, _ctx))

        '''Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See Channel.id.
    session Connection ID of user. See User.session.
    group Group name to add to.'''
        def end_addUserToGroup(self, _r):
            return _M_Murmur.Server._op_addUserToGroup.end(self, _r)

        '''Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See Channel.id.
    session Connection ID of user. See User.session.
    group Group name to remove from.'''
        def removeUserFromGroup(self, channelid, session, group, _ctx=None):
            return _M_Murmur.Server._op_removeUserFromGroup.invoke(self, ((channelid, session, group), _ctx))

        '''Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See Channel.id.
    session Connection ID of user. See User.session.
    group Group name to remove from.'''
        def begin_removeUserFromGroup(self, channelid, session, group, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_removeUserFromGroup.begin(self, ((channelid, session, group), _response, _ex, _sent, _ctx))

        '''Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See Channel.id.
    session Connection ID of user. See User.session.
    group Group name to remove from.'''
        def end_removeUserFromGroup(self, _r):
            return _M_Murmur.Server._op_removeUserFromGroup.end(self, _r)

        '''Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
To remove a redirect pass an empty target string. This is intended for context groups.
Arguments:
    session Connection ID of user. See User.session.
    source Group name to redirect from.
    target Group name to redirect to.'''
        def redirectWhisperGroup(self, session, source, target, _ctx=None):
            return _M_Murmur.Server._op_redirectWhisperGroup.invoke(self, ((session, source, target), _ctx))

        '''Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
To remove a redirect pass an empty target string. This is intended for context groups.
Arguments:
    session Connection ID of user. See User.session.
    source Group name to redirect from.
    target Group name to redirect to.'''
        def begin_redirectWhisperGroup(self, session, source, target, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_redirectWhisperGroup.begin(self, ((session, source, target), _response, _ex, _sent, _ctx))

        '''Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
To remove a redirect pass an empty target string. This is intended for context groups.
Arguments:
    session Connection ID of user. See User.session.
    source Group name to redirect from.
    target Group name to redirect to.'''
        def end_redirectWhisperGroup(self, _r):
            return _M_Murmur.Server._op_redirectWhisperGroup.end(self, _r)

        '''Map a list of User.userid to a matching name.
Arguments:
    List of ids.
Returns:
    Matching list of names, with an empty string representing invalid or unknown ids.'''
        def getUserNames(self, ids, _ctx=None):
            return _M_Murmur.Server._op_getUserNames.invoke(self, ((ids, ), _ctx))

        '''Map a list of User.userid to a matching name.
Arguments:
    List of ids.
Returns:
    Matching list of names, with an empty string representing invalid or unknown ids.'''
        def begin_getUserNames(self, ids, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getUserNames.begin(self, ((ids, ), _response, _ex, _sent, _ctx))

        '''Map a list of User.userid to a matching name.
Arguments:
    List of ids.
Returns:
    Matching list of names, with an empty string representing invalid or unknown ids.'''
        def end_getUserNames(self, _r):
            return _M_Murmur.Server._op_getUserNames.end(self, _r)

        '''Map a list of user names to a matching id.
Arguments:
    List of names.
@reuturn List of matching ids, with -1 representing invalid or unknown user names.'''
        def getUserIds(self, names, _ctx=None):
            return _M_Murmur.Server._op_getUserIds.invoke(self, ((names, ), _ctx))

        '''Map a list of user names to a matching id.
Arguments:
    List of names.
@reuturn List of matching ids, with -1 representing invalid or unknown user names.'''
        def begin_getUserIds(self, names, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getUserIds.begin(self, ((names, ), _response, _ex, _sent, _ctx))

        '''Map a list of user names to a matching id.
Arguments:
    List of names.
@reuturn List of matching ids, with -1 representing invalid or unknown user names.'''
        def end_getUserIds(self, _r):
            return _M_Murmur.Server._op_getUserIds.end(self, _r)

        '''Register a new user.
Arguments:
    info Information about new user. Must include at least "name".
Returns:
    The ID of the user. See RegisteredUser.userid.'''
        def registerUser(self, info, _ctx=None):
            return _M_Murmur.Server._op_registerUser.invoke(self, ((info, ), _ctx))

        '''Register a new user.
Arguments:
    info Information about new user. Must include at least "name".
Returns:
    The ID of the user. See RegisteredUser.userid.'''
        def begin_registerUser(self, info, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_registerUser.begin(self, ((info, ), _response, _ex, _sent, _ctx))

        '''Register a new user.
Arguments:
    info Information about new user. Must include at least "name".
Returns:
    The ID of the user. See RegisteredUser.userid.'''
        def end_registerUser(self, _r):
            return _M_Murmur.Server._op_registerUser.end(self, _r)

        '''Remove a user registration.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.'''
        def unregisterUser(self, userid, _ctx=None):
            return _M_Murmur.Server._op_unregisterUser.invoke(self, ((userid, ), _ctx))

        '''Remove a user registration.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.'''
        def begin_unregisterUser(self, userid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_unregisterUser.begin(self, ((userid, ), _response, _ex, _sent, _ctx))

        '''Remove a user registration.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.'''
        def end_unregisterUser(self, _r):
            return _M_Murmur.Server._op_unregisterUser.end(self, _r)

        '''Update the registration for a user. You can use this to set the email or password of a user,
and can also use it to change the user's name.
Arguments:
    registration Updated registration record.'''
        def updateRegistration(self, userid, info, _ctx=None):
            return _M_Murmur.Server._op_updateRegistration.invoke(self, ((userid, info), _ctx))

        '''Update the registration for a user. You can use this to set the email or password of a user,
and can also use it to change the user's name.
Arguments:
    registration Updated registration record.'''
        def begin_updateRegistration(self, userid, info, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_updateRegistration.begin(self, ((userid, info), _response, _ex, _sent, _ctx))

        '''Update the registration for a user. You can use this to set the email or password of a user,
and can also use it to change the user's name.
Arguments:
    registration Updated registration record.'''
        def end_updateRegistration(self, _r):
            return _M_Murmur.Server._op_updateRegistration.end(self, _r)

        '''Fetch registration for a single user.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
Returns:
    Registration record.'''
        def getRegistration(self, userid, _ctx=None):
            return _M_Murmur.Server._op_getRegistration.invoke(self, ((userid, ), _ctx))

        '''Fetch registration for a single user.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
Returns:
    Registration record.'''
        def begin_getRegistration(self, userid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getRegistration.begin(self, ((userid, ), _response, _ex, _sent, _ctx))

        '''Fetch registration for a single user.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
Returns:
    Registration record.'''
        def end_getRegistration(self, _r):
            return _M_Murmur.Server._op_getRegistration.end(self, _r)

        '''Fetch a group of registered users.
Arguments:
    filter Substring of user name. If blank, will retrieve all registered users.
Returns:
    List of registration records.'''
        def getRegisteredUsers(self, filter, _ctx=None):
            return _M_Murmur.Server._op_getRegisteredUsers.invoke(self, ((filter, ), _ctx))

        '''Fetch a group of registered users.
Arguments:
    filter Substring of user name. If blank, will retrieve all registered users.
Returns:
    List of registration records.'''
        def begin_getRegisteredUsers(self, filter, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getRegisteredUsers.begin(self, ((filter, ), _response, _ex, _sent, _ctx))

        '''Fetch a group of registered users.
Arguments:
    filter Substring of user name. If blank, will retrieve all registered users.
Returns:
    List of registration records.'''
        def end_getRegisteredUsers(self, _r):
            return _M_Murmur.Server._op_getRegisteredUsers.end(self, _r)

        '''Verify the password of a user. You can use this to verify a user's credentials.
Arguments:
    name User name. See RegisteredUser.name.
    pw User password.
Returns:
    User ID of registered user (See RegisteredUser.userid), -1 for failed authentication or -2 for unknown usernames.'''
        def verifyPassword(self, name, pw, _ctx=None):
            return _M_Murmur.Server._op_verifyPassword.invoke(self, ((name, pw), _ctx))

        '''Verify the password of a user. You can use this to verify a user's credentials.
Arguments:
    name User name. See RegisteredUser.name.
    pw User password.
Returns:
    User ID of registered user (See RegisteredUser.userid), -1 for failed authentication or -2 for unknown usernames.'''
        def begin_verifyPassword(self, name, pw, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_verifyPassword.begin(self, ((name, pw), _response, _ex, _sent, _ctx))

        '''Verify the password of a user. You can use this to verify a user's credentials.
Arguments:
    name User name. See RegisteredUser.name.
    pw User password.
Returns:
    User ID of registered user (See RegisteredUser.userid), -1 for failed authentication or -2 for unknown usernames.'''
        def end_verifyPassword(self, _r):
            return _M_Murmur.Server._op_verifyPassword.end(self, _r)

        '''Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
Returns:
    Custom texture associated with user or an empty texture.'''
        def getTexture(self, userid, _ctx=None):
            return _M_Murmur.Server._op_getTexture.invoke(self, ((userid, ), _ctx))

        '''Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
Returns:
    Custom texture associated with user or an empty texture.'''
        def begin_getTexture(self, userid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getTexture.begin(self, ((userid, ), _response, _ex, _sent, _ctx))

        '''Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
Returns:
    Custom texture associated with user or an empty texture.'''
        def end_getTexture(self, _r):
            return _M_Murmur.Server._op_getTexture.end(self, _r)

        '''Set a user texture (now called avatar).
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
    tex Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.'''
        def setTexture(self, userid, tex, _ctx=None):
            return _M_Murmur.Server._op_setTexture.invoke(self, ((userid, tex), _ctx))

        '''Set a user texture (now called avatar).
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
    tex Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.'''
        def begin_setTexture(self, userid, tex, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setTexture.begin(self, ((userid, tex), _response, _ex, _sent, _ctx))

        '''Set a user texture (now called avatar).
Arguments:
    userid ID of registered user. See RegisteredUser.userid.
    tex Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.'''
        def end_setTexture(self, _r):
            return _M_Murmur.Server._op_setTexture.end(self, _r)

        '''Get virtual server uptime.
Returns:
    Uptime of the virtual server in seconds'''
        def getUptime(self, _ctx=None):
            return _M_Murmur.Server._op_getUptime.invoke(self, ((), _ctx))

        '''Get virtual server uptime.
Returns:
    Uptime of the virtual server in seconds'''
        def begin_getUptime(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getUptime.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get virtual server uptime.
Returns:
    Uptime of the virtual server in seconds'''
        def end_getUptime(self, _r):
            return _M_Murmur.Server._op_getUptime.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerPrx.ice_checkedCast(proxy, '::Murmur::Server', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::Murmur::Server'
        ice_staticId = staticmethod(ice_staticId)

    _M_Murmur._t_ServerPrx = IcePy.defineProxy('::Murmur::Server', ServerPrx)

    _M_Murmur._t_Server = IcePy.defineClass('::Murmur::Server', Server, -1, (), True, False, None, (), ())
    Server._ice_type = _M_Murmur._t_Server

    Server._op_isRunning = IcePy.Operation('isRunning', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_start = IcePy.Operation('start', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_ServerFailureException, _M_Murmur._t_InvalidSecretException))
    Server._op_stop = IcePy.Operation('stop', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_delete = IcePy.Operation('delete', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_id = IcePy.Operation('id', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_addCallback = IcePy.Operation('addCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_ServerCallbackPrx, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_removeCallback = IcePy.Operation('removeCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_ServerCallbackPrx, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_setAuthenticator = IcePy.Operation('setAuthenticator', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_ServerAuthenticatorPrx, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_getConf = IcePy.Operation('getConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_string, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_getAllConf = IcePy.Operation('getAllConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ConfigMap, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_setConf = IcePy.Operation('setConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_InvalidSecretException,))
    Server._op_setSuperuserPassword = IcePy.Operation('setSuperuserPassword', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0),), (), None, (_M_Murmur._t_InvalidSecretException,))
    Server._op_getLog = IcePy.Operation('getLog', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), _M_Murmur._t_LogList, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_getLogLen = IcePy.Operation('getLogLen', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_getUsers = IcePy.Operation('getUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_UserMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getChannels = IcePy.Operation('getChannels', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ChannelMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getCertificateList = IcePy.Operation('getCertificateList', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_CertificateList, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_getTree = IcePy.Operation('getTree', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_Tree, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getBans = IcePy.Operation('getBans', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_BanList, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_setBans = IcePy.Operation('setBans', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_BanList, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_kickUser = IcePy.Operation('kickUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_getState = IcePy.Operation('getState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_User, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_setState = IcePy.Operation('setState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_User, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_sendMessage = IcePy.Operation('sendMessage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_hasPermission = IcePy.Operation('hasPermission', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_bool, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_effectivePermissions = IcePy.Operation('effectivePermissions', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_addContextCallback = IcePy.Operation('addContextCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), _M_Murmur._t_ServerContextCallbackPrx, False, 0), ((), IcePy._t_int, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_removeContextCallback = IcePy.Operation('removeContextCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_ServerContextCallbackPrx, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_getChannelState = IcePy.Operation('getChannelState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_Channel, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_setChannelState = IcePy.Operation('setChannelState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_Channel, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException, _M_Murmur._t_NestingLimitException))
    Server._op_removeChannel = IcePy.Operation('removeChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_addChannel = IcePy.Operation('addChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException, _M_Murmur._t_NestingLimitException))
    Server._op_sendMessageChannel = IcePy.Operation('sendMessageChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_bool, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_getACL = IcePy.Operation('getACL', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (((), _M_Murmur._t_ACLList, False, 0), ((), _M_Murmur._t_GroupList, False, 0), ((), IcePy._t_bool, False, 0)), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_setACL = IcePy.Operation('setACL', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_ACLList, False, 0), ((), _M_Murmur._t_GroupList, False, 0), ((), IcePy._t_bool, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_addUserToGroup = IcePy.Operation('addUserToGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_removeUserFromGroup = IcePy.Operation('removeUserFromGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_redirectWhisperGroup = IcePy.Operation('redirectWhisperGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_getUserNames = IcePy.Operation('getUserNames', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_IdList, False, 0),), (), ((), _M_Murmur._t_NameMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getUserIds = IcePy.Operation('getUserIds', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_NameList, False, 0),), (), ((), _M_Murmur._t_IdMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_registerUser = IcePy.Operation('registerUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_UserInfoMap, False, 0),), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_unregisterUser = IcePy.Operation('unregisterUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_updateRegistration = IcePy.Operation('updateRegistration', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_UserInfoMap, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_getRegistration = IcePy.Operation('getRegistration', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_UserInfoMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_getRegisteredUsers = IcePy.Operation('getRegisteredUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_Murmur._t_NameMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_verifyPassword = IcePy.Operation('verifyPassword', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getTexture = IcePy.Operation('getTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_Texture, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_setTexture = IcePy.Operation('setTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_Texture, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidTextureException, _M_Murmur._t_InvalidSecretException))
    Server._op_getUptime = IcePy.Operation('getUptime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))

    _M_Murmur.Server = Server
    del Server

    _M_Murmur.ServerPrx = ServerPrx
    del ServerPrx

if 'MetaCallback' not in _M_Murmur.__dict__:
    _M_Murmur.MetaCallback = Ice.createTempClass()
    class MetaCallback(Ice.Object):
        '''Callback interface for Meta. You can supply an implementation of this to receive notifications
when servers are stopped or started.
If an added callback ever throws an exception or goes away, it will be automatically removed.
Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
complete before continuing processing.'''
        def __init__(self):
            if Ice.getType(self) == _M_Murmur.MetaCallback:
                raise RuntimeError('Murmur.MetaCallback is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::MetaCallback')

        def ice_id(self, current=None):
            return '::Murmur::MetaCallback'

        def ice_staticId():
            return '::Murmur::MetaCallback'
        ice_staticId = staticmethod(ice_staticId)

        def started(self, srv, current=None):
            '''Called when a server is started. The server is up and running when this event is sent, so all methods that 
need a running server will work.
Arguments:
    srv Interface for started server.'''
            pass

        def stopped(self, srv, current=None):
            '''Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
need a running server will work.
Arguments:
    srv Interface for started server.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_MetaCallback)

        __repr__ = __str__

    _M_Murmur.MetaCallbackPrx = Ice.createTempClass()
    class MetaCallbackPrx(Ice.ObjectPrx):

        '''Called when a server is started. The server is up and running when this event is sent, so all methods that 
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def started(self, srv, _ctx=None):
            return _M_Murmur.MetaCallback._op_started.invoke(self, ((srv, ), _ctx))

        '''Called when a server is started. The server is up and running when this event is sent, so all methods that 
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def begin_started(self, srv, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.MetaCallback._op_started.begin(self, ((srv, ), _response, _ex, _sent, _ctx))

        '''Called when a server is started. The server is up and running when this event is sent, so all methods that 
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def end_started(self, _r):
            return _M_Murmur.MetaCallback._op_started.end(self, _r)

        '''Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def stopped(self, srv, _ctx=None):
            return _M_Murmur.MetaCallback._op_stopped.invoke(self, ((srv, ), _ctx))

        '''Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def begin_stopped(self, srv, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.MetaCallback._op_stopped.begin(self, ((srv, ), _response, _ex, _sent, _ctx))

        '''Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def end_stopped(self, _r):
            return _M_Murmur.MetaCallback._op_stopped.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.MetaCallbackPrx.ice_checkedCast(proxy, '::Murmur::MetaCallback', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.MetaCallbackPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::Murmur::MetaCallback'
        ice_staticId = staticmethod(ice_staticId)

    _M_Murmur._t_MetaCallbackPrx = IcePy.defineProxy('::Murmur::MetaCallback', MetaCallbackPrx)

    _M_Murmur._t_MetaCallback = IcePy.defineClass('::Murmur::MetaCallback', MetaCallback, -1, (), True, False, None, (), ())
    MetaCallback._ice_type = _M_Murmur._t_MetaCallback

    MetaCallback._op_started = IcePy.Operation('started', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Murmur._t_ServerPrx, False, 0),), (), None, ())
    MetaCallback._op_stopped = IcePy.Operation('stopped', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Murmur._t_ServerPrx, False, 0),), (), None, ())

    _M_Murmur.MetaCallback = MetaCallback
    del MetaCallback

    _M_Murmur.MetaCallbackPrx = MetaCallbackPrx
    del MetaCallbackPrx

if '_t_ServerList' not in _M_Murmur.__dict__:
    _M_Murmur._t_ServerList = IcePy.defineSequence('::Murmur::ServerList', (), _M_Murmur._t_ServerPrx)

if 'Meta' not in _M_Murmur.__dict__:
    _M_Murmur.Meta = Ice.createTempClass()
    class Meta(Ice.Object):
        '''This is the meta interface. It is primarily used for retrieving the Server interfaces for each individual server.'''
        def __init__(self):
            if Ice.getType(self) == _M_Murmur.Meta:
                raise RuntimeError('Murmur.Meta is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::Meta')

        def ice_id(self, current=None):
            return '::Murmur::Meta'

        def ice_staticId():
            return '::Murmur::Meta'
        ice_staticId = staticmethod(ice_staticId)

        def getServer_async(self, _cb, id, current=None):
            '''Fetch interface to specific server.
Arguments:
    id Server ID. See Server.getId.
Returns:
    Interface for specified server, or a null proxy if id is invalid.'''
            pass

        def newServer_async(self, _cb, current=None):
            '''Create a new server. Call Server.getId on the returned interface to find it's ID.
Returns:
    Interface for new server.'''
            pass

        def getBootedServers_async(self, _cb, current=None):
            '''Fetch list of all currently running servers.
Returns:
    List of interfaces for running servers.'''
            pass

        def getAllServers_async(self, _cb, current=None):
            '''Fetch list of all defined servers.
Returns:
    List of interfaces for all servers.'''
            pass

        def getDefaultConf_async(self, _cb, current=None):
            '''Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
the built-in default. The individual servers will use these values unless they have been overridden in the
server specific configuration. The only special case is the port, which defaults to the value defined here +
the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
Returns:
    Default configuration of the servers.'''
            pass

        def getVersion_async(self, _cb, current=None):
            '''Fetch version of Murmur. 
Arguments:
    major Major version.
    minor Minor version.
    patch Patchlevel.
    text Textual representation of version. Note that this may not match the major, minor and patch levels, as it
may be simply the compile date or the SVN revision. This is usually the text you want to present to users.'''
            pass

        def addCallback_async(self, _cb, cb, current=None):
            '''Add a callback. The callback will receive notifications when servers are started or stopped.

Arguments:
    cb Callback interface which will receive notifications.'''
            pass

        def removeCallback_async(self, _cb, cb, current=None):
            '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
            pass

        def getUptime_async(self, _cb, current=None):
            '''Get murmur uptime.
Returns:
    Uptime of murmur in seconds'''
            pass

        def getSlice_async(self, _cb, current=None):
            '''Get slice file.
Returns:
    Contents of the slice file server compiled with.'''
            pass

        def getSliceChecksums_async(self, _cb, current=None):
            '''Returns a checksum dict for the slice file.
Returns:
    Checksum dict'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Meta)

        __repr__ = __str__

    _M_Murmur.MetaPrx = Ice.createTempClass()
    class MetaPrx(Ice.ObjectPrx):

        '''Fetch interface to specific server.
Arguments:
    id Server ID. See Server.getId.
Returns:
    Interface for specified server, or a null proxy if id is invalid.'''
        def getServer(self, id, _ctx=None):
            return _M_Murmur.Meta._op_getServer.invoke(self, ((id, ), _ctx))

        '''Fetch interface to specific server.
Arguments:
    id Server ID. See Server.getId.
Returns:
    Interface for specified server, or a null proxy if id is invalid.'''
        def begin_getServer(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getServer.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Fetch interface to specific server.
Arguments:
    id Server ID. See Server.getId.
Returns:
    Interface for specified server, or a null proxy if id is invalid.'''
        def end_getServer(self, _r):
            return _M_Murmur.Meta._op_getServer.end(self, _r)

        '''Create a new server. Call Server.getId on the returned interface to find it's ID.
Returns:
    Interface for new server.'''
        def newServer(self, _ctx=None):
            return _M_Murmur.Meta._op_newServer.invoke(self, ((), _ctx))

        '''Create a new server. Call Server.getId on the returned interface to find it's ID.
Returns:
    Interface for new server.'''
        def begin_newServer(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_newServer.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Create a new server. Call Server.getId on the returned interface to find it's ID.
Returns:
    Interface for new server.'''
        def end_newServer(self, _r):
            return _M_Murmur.Meta._op_newServer.end(self, _r)

        '''Fetch list of all currently running servers.
Returns:
    List of interfaces for running servers.'''
        def getBootedServers(self, _ctx=None):
            return _M_Murmur.Meta._op_getBootedServers.invoke(self, ((), _ctx))

        '''Fetch list of all currently running servers.
Returns:
    List of interfaces for running servers.'''
        def begin_getBootedServers(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getBootedServers.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch list of all currently running servers.
Returns:
    List of interfaces for running servers.'''
        def end_getBootedServers(self, _r):
            return _M_Murmur.Meta._op_getBootedServers.end(self, _r)

        '''Fetch list of all defined servers.
Returns:
    List of interfaces for all servers.'''
        def getAllServers(self, _ctx=None):
            return _M_Murmur.Meta._op_getAllServers.invoke(self, ((), _ctx))

        '''Fetch list of all defined servers.
Returns:
    List of interfaces for all servers.'''
        def begin_getAllServers(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getAllServers.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch list of all defined servers.
Returns:
    List of interfaces for all servers.'''
        def end_getAllServers(self, _r):
            return _M_Murmur.Meta._op_getAllServers.end(self, _r)

        '''Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
the built-in default. The individual servers will use these values unless they have been overridden in the
server specific configuration. The only special case is the port, which defaults to the value defined here +
the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
Returns:
    Default configuration of the servers.'''
        def getDefaultConf(self, _ctx=None):
            return _M_Murmur.Meta._op_getDefaultConf.invoke(self, ((), _ctx))

        '''Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
the built-in default. The individual servers will use these values unless they have been overridden in the
server specific configuration. The only special case is the port, which defaults to the value defined here +
the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
Returns:
    Default configuration of the servers.'''
        def begin_getDefaultConf(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getDefaultConf.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
the built-in default. The individual servers will use these values unless they have been overridden in the
server specific configuration. The only special case is the port, which defaults to the value defined here +
the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
Returns:
    Default configuration of the servers.'''
        def end_getDefaultConf(self, _r):
            return _M_Murmur.Meta._op_getDefaultConf.end(self, _r)

        '''Fetch version of Murmur. 
Arguments:
    major Major version.
    minor Minor version.
    patch Patchlevel.
    text Textual representation of version. Note that this may not match the major, minor and patch levels, as it
may be simply the compile date or the SVN revision. This is usually the text you want to present to users.'''
        def getVersion(self, _ctx=None):
            return _M_Murmur.Meta._op_getVersion.invoke(self, ((), _ctx))

        '''Fetch version of Murmur. 
Arguments:
    major Major version.
    minor Minor version.
    patch Patchlevel.
    text Textual representation of version. Note that this may not match the major, minor and patch levels, as it
may be simply the compile date or the SVN revision. This is usually the text you want to present to users.'''
        def begin_getVersion(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getVersion.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch version of Murmur. 
Arguments:
    major Major version.
    minor Minor version.
    patch Patchlevel.
    text Textual representation of version. Note that this may not match the major, minor and patch levels, as it
may be simply the compile date or the SVN revision. This is usually the text you want to present to users.'''
        def end_getVersion(self, _r):
            return _M_Murmur.Meta._op_getVersion.end(self, _r)

        '''Add a callback. The callback will receive notifications when servers are started or stopped.

Arguments:
    cb Callback interface which will receive notifications.'''
        def addCallback(self, cb, _ctx=None):
            return _M_Murmur.Meta._op_addCallback.invoke(self, ((cb, ), _ctx))

        '''Add a callback. The callback will receive notifications when servers are started or stopped.

Arguments:
    cb Callback interface which will receive notifications.'''
        def begin_addCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_addCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Add a callback. The callback will receive notifications when servers are started or stopped.

Arguments:
    cb Callback interface which will receive notifications.'''
        def end_addCallback(self, _r):
            return _M_Murmur.Meta._op_addCallback.end(self, _r)

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def removeCallback(self, cb, _ctx=None):
            return _M_Murmur.Meta._op_removeCallback.invoke(self, ((cb, ), _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def begin_removeCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_removeCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def end_removeCallback(self, _r):
            return _M_Murmur.Meta._op_removeCallback.end(self, _r)

        '''Get murmur uptime.
Returns:
    Uptime of murmur in seconds'''
        def getUptime(self, _ctx=None):
            return _M_Murmur.Meta._op_getUptime.invoke(self, ((), _ctx))

        '''Get murmur uptime.
Returns:
    Uptime of murmur in seconds'''
        def begin_getUptime(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getUptime.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get murmur uptime.
Returns:
    Uptime of murmur in seconds'''
        def end_getUptime(self, _r):
            return _M_Murmur.Meta._op_getUptime.end(self, _r)

        '''Get slice file.
Returns:
    Contents of the slice file server compiled with.'''
        def getSlice(self, _ctx=None):
            return _M_Murmur.Meta._op_getSlice.invoke(self, ((), _ctx))

        '''Get slice file.
Returns:
    Contents of the slice file server compiled with.'''
        def begin_getSlice(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getSlice.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get slice file.
Returns:
    Contents of the slice file server compiled with.'''
        def end_getSlice(self, _r):
            return _M_Murmur.Meta._op_getSlice.end(self, _r)

        '''Returns a checksum dict for the slice file.
Returns:
    Checksum dict'''
        def getSliceChecksums(self, _ctx=None):
            return _M_Murmur.Meta._op_getSliceChecksums.invoke(self, ((), _ctx))

        '''Returns a checksum dict for the slice file.
Returns:
    Checksum dict'''
        def begin_getSliceChecksums(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getSliceChecksums.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns a checksum dict for the slice file.
Returns:
    Checksum dict'''
        def end_getSliceChecksums(self, _r):
            return _M_Murmur.Meta._op_getSliceChecksums.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.MetaPrx.ice_checkedCast(proxy, '::Murmur::Meta', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.MetaPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::Murmur::Meta'
        ice_staticId = staticmethod(ice_staticId)

    _M_Murmur._t_MetaPrx = IcePy.defineProxy('::Murmur::Meta', MetaPrx)

    _M_Murmur._t_Meta = IcePy.defineClass('::Murmur::Meta', Meta, -1, (), True, False, None, (), ())
    Meta._ice_type = _M_Murmur._t_Meta

    Meta._op_getServer = IcePy.Operation('getServer', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_ServerPrx, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_newServer = IcePy.Operation('newServer', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), ((), _M_Murmur._t_ServerPrx, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_getBootedServers = IcePy.Operation('getBootedServers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ServerList, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_getAllServers = IcePy.Operation('getAllServers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ServerList, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_getDefaultConf = IcePy.Operation('getDefaultConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ConfigMap, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_getVersion = IcePy.Operation('getVersion', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), None, ())
    Meta._op_addCallback = IcePy.Operation('addCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_MetaCallbackPrx, False, 0),), (), None, (_M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Meta._op_removeCallback = IcePy.Operation('removeCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_MetaCallbackPrx, False, 0),), (), None, (_M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Meta._op_getUptime = IcePy.Operation('getUptime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_int, False, 0), ())
    Meta._op_getSlice = IcePy.Operation('getSlice', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Meta._op_getSliceChecksums = IcePy.Operation('getSliceChecksums', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Ice._t_SliceChecksumDict, False, 0), ())

    _M_Murmur.Meta = Meta
    del Meta

    _M_Murmur.MetaPrx = MetaPrx
    del MetaPrx

# End of module Murmur
